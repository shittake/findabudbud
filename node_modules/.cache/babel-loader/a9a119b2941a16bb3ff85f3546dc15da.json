{"ast":null,"code":"import _classCallCheck from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\n\nvar RealtimeSubscription = /*#__PURE__*/function () {\n  function RealtimeSubscription(topic) {\n    var _this = this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var socket = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, RealtimeSubscription);\n\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = [];\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(function () {\n      return _this.rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', function () {\n      _this.state = CHANNEL_STATES.joined;\n\n      _this.rejoinTimer.reset();\n\n      _this.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n\n      _this.pushBuffer = [];\n    });\n    this.onClose(function () {\n      _this.rejoinTimer.reset();\n\n      _this.socket.log('channel', \"close \".concat(_this.topic, \" \").concat(_this.joinRef()));\n\n      _this.state = CHANNEL_STATES.closed;\n\n      _this.socket.remove(_this);\n    });\n    this.onError(function (reason) {\n      if (_this.isLeaving() || _this.isClosed()) {\n        return;\n      }\n\n      _this.socket.log('channel', \"error \".concat(_this.topic), reason);\n\n      _this.state = CHANNEL_STATES.errored;\n\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', function () {\n      if (!_this.isJoining()) {\n        return;\n      }\n\n      _this.socket.log('channel', \"timeout \".concat(_this.topic), _this.joinPush.timeout);\n\n      _this.state = CHANNEL_STATES.errored;\n\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, function (payload, ref) {\n      _this.trigger(_this.replyEventName(ref), payload);\n    });\n  }\n\n  _createClass(RealtimeSubscription, [{\n    key: \"rejoinUntilConnected\",\n    value: function rejoinUntilConnected() {\n      this.rejoinTimer.scheduleTimeout();\n\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.joinedOnce) {\n        throw \"tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance\";\n      } else {\n        this.joinedOnce = true;\n        this.rejoin(timeout);\n        return this.joinPush;\n      }\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.on(CHANNEL_EVENTS.error, function (reason) {\n        return callback(reason);\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      this.bindings.push({\n        event: event,\n        callback: callback\n      });\n    }\n  }, {\n    key: \"off\",\n    value: function off(event) {\n      this.bindings = this.bindings.filter(function (bind) {\n        return bind.event !== event;\n      });\n    }\n  }, {\n    key: \"canPush\",\n    value: function canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n  }, {\n    key: \"push\",\n    value: function push(event, payload) {\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n\n      if (!this.joinedOnce) {\n        throw \"tried to push '\".concat(event, \"' to '\").concat(this.topic, \"' before joining. Use channel.subscribe() before pushing events\");\n      }\n\n      var pushEvent = new Push(this, event, payload, timeout);\n\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n  }, {\n    key: \"updateJoinPayload\",\n    value: function updateJoinPayload(payload) {\n      this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _this2 = this;\n\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      this.state = CHANNEL_STATES.leaving;\n\n      var onClose = function onClose() {\n        _this2.socket.log('channel', \"leave \".concat(_this2.topic));\n\n        _this2.trigger(CHANNEL_EVENTS.close, 'leave', _this2.joinRef());\n      }; // Destroy joinPush to avoid connection timeouts during unscription phase\n\n\n      this.joinPush.destroy();\n      var leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', function () {\n        return onClose();\n      }).receive('timeout', function () {\n        return onClose();\n      });\n      leavePush.send();\n\n      if (!this.canPush()) {\n        leavePush.trigger('ok', {});\n      }\n\n      return leavePush;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     */\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event, payload, ref) {\n      return payload;\n    }\n  }, {\n    key: \"isMember\",\n    value: function isMember(topic) {\n      return this.topic === topic;\n    }\n  }, {\n    key: \"joinRef\",\n    value: function joinRef() {\n      return this.joinPush.ref;\n    }\n  }, {\n    key: \"rejoin\",\n    value: function rejoin() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.isLeaving()) {\n        return;\n      }\n\n      this.socket.leaveOpenTopic(this.topic);\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(event, payload, ref) {\n      var close = CHANNEL_EVENTS.close,\n          error = CHANNEL_EVENTS.error,\n          leave = CHANNEL_EVENTS.leave,\n          join = CHANNEL_EVENTS.join;\n      var events = [close, error, leave, join];\n\n      if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {\n        return;\n      }\n\n      var handledPayload = this.onMessage(event, payload, ref);\n\n      if (payload && !handledPayload) {\n        throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n      }\n\n      this.bindings.filter(function (bind) {\n        // Bind all events if the user specifies a wildcard.\n        if (bind.event === '*') {\n          return event === (payload === null || payload === void 0 ? void 0 : payload.type);\n        } else {\n          return bind.event === event;\n        }\n      }).map(function (bind) {\n        return bind.callback(handledPayload, ref);\n      });\n    }\n  }, {\n    key: \"replyEventName\",\n    value: function replyEventName(ref) {\n      return \"chan_reply_\".concat(ref);\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n  }, {\n    key: \"isErrored\",\n    value: function isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n  }, {\n    key: \"isJoined\",\n    value: function isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n  }, {\n    key: \"isJoining\",\n    value: function isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n  }, {\n    key: \"isLeaving\",\n    value: function isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n  }]);\n\n  return RealtimeSubscription;\n}();\n\nexport { RealtimeSubscription as default };","map":{"version":3,"sources":["../../src/RealtimeSubscription.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nexport default class RealtimeSubscription {\n    constructor(topic, params = {}, socket) {\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = [];\n        this.state = CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.timeout = this.socket.timeout;\n        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new Timer(() => this.rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', () => {\n            this.state = CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this.onClose(() => {\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`);\n            this.state = CHANNEL_STATES.closed;\n            this.socket.remove(this);\n        });\n        this.onError((reason) => {\n            if (this.isLeaving() || this.isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', () => {\n            if (!this.isJoining()) {\n                return;\n            }\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n            this.trigger(this.replyEventName(ref), payload);\n        });\n    }\n    rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this.rejoin();\n        }\n    }\n    subscribe(timeout = this.timeout) {\n        if (this.joinedOnce) {\n            throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n        }\n        else {\n            this.joinedOnce = true;\n            this.rejoin(timeout);\n            return this.joinPush;\n        }\n    }\n    onClose(callback) {\n        this.on(CHANNEL_EVENTS.close, callback);\n    }\n    onError(callback) {\n        this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));\n    }\n    on(event, callback) {\n        this.bindings.push({ event, callback });\n    }\n    off(event) {\n        this.bindings = this.bindings.filter((bind) => bind.event !== event);\n    }\n    canPush() {\n        return this.socket.isConnected() && this.isJoined();\n    }\n    push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new Push(this, event, payload, timeout);\n        if (this.canPush()) {\n            pushEvent.send();\n        }\n        else {\n            pushEvent.startTimeout();\n            this.pushBuffer.push(pushEvent);\n        }\n        return pushEvent;\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n    unsubscribe(timeout = this.timeout) {\n        this.state = CHANNEL_STATES.leaving;\n        let onClose = () => {\n            this.socket.log('channel', `leave ${this.topic}`);\n            this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef());\n        };\n        // Destroy joinPush to avoid connection timeouts during unscription phase\n        this.joinPush.destroy();\n        let leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n        leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose());\n        leavePush.send();\n        if (!this.canPush()) {\n            leavePush.trigger('ok', {});\n        }\n        return leavePush;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     */\n    onMessage(event, payload, ref) {\n        return payload;\n    }\n    isMember(topic) {\n        return this.topic === topic;\n    }\n    joinRef() {\n        return this.joinPush.ref;\n    }\n    rejoin(timeout = this.timeout) {\n        if (this.isLeaving()) {\n            return;\n        }\n        this.socket.leaveOpenTopic(this.topic);\n        this.state = CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    trigger(event, payload, ref) {\n        let { close, error, leave, join } = CHANNEL_EVENTS;\n        let events = [close, error, leave, join];\n        if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {\n            return;\n        }\n        let handledPayload = this.onMessage(event, payload, ref);\n        if (payload && !handledPayload) {\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        }\n        this.bindings\n            .filter((bind) => {\n            // Bind all events if the user specifies a wildcard.\n            if (bind.event === '*') {\n                return event === (payload === null || payload === void 0 ? void 0 : payload.type);\n            }\n            else {\n                return bind.event === event;\n            }\n        })\n            .map((bind) => bind.callback(handledPayload, ref));\n    }\n    replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    isClosed() {\n        return this.state === CHANNEL_STATES.closed;\n    }\n    isErrored() {\n        return this.state === CHANNEL_STATES.errored;\n    }\n    isJoined() {\n        return this.state === CHANNEL_STATES.joined;\n    }\n    isJoining() {\n        return this.state === CHANNEL_STATES.joining;\n    }\n    isLeaving() {\n        return this.state === CHANNEL_STATES.leaving;\n    }\n}\n//# sourceMappingURL=RealtimeSubscription.js.map"]},"metadata":{},"sourceType":"module"}