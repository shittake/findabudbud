{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { get, post, remove as _remove } from './fetch';\nimport { resolveFetch } from './helpers';\nvar DEFAULT_SEARCH_OPTIONS = {\n  limit: 100,\n  offset: 0,\n  sortBy: {\n    column: 'name',\n    order: 'asc'\n  }\n};\nvar DEFAULT_FILE_OPTIONS = {\n  cacheControl: '3600',\n  contentType: 'text/plain;charset=UTF-8',\n  upsert: false\n};\nexport var StorageFileApi = /*#__PURE__*/function () {\n  function StorageFileApi(url) {\n    var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var bucketId = arguments.length > 2 ? arguments[2] : undefined;\n    var fetch = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, StorageFileApi);\n\n    this.url = url;\n    this.headers = headers;\n    this.bucketId = bucketId;\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\n   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n   *\n   * @param method HTTP method.\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   * @param fileOptions HTTP headers.\n   * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n   * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n   * `upsert`: boolean, whether to perform an upsert.\n   */\n\n\n  _createClass(StorageFileApi, [{\n    key: \"uploadOrUpdate\",\n    value: function uploadOrUpdate(method, path, fileBody, fileOptions) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var body, options, headers, cleanPath, _path, res, error;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);\n                headers = Object.assign(Object.assign({}, this.headers), method === 'POST' && {\n                  'x-upsert': String(options.upsert)\n                });\n\n                if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n                  body = new FormData();\n                  body.append('cacheControl', options.cacheControl);\n                  body.append('', fileBody);\n                } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n                  body = fileBody;\n                  body.append('cacheControl', options.cacheControl);\n                } else {\n                  body = fileBody;\n                  headers['cache-control'] = \"max-age=\".concat(options.cacheControl);\n                  headers['content-type'] = options.contentType;\n                }\n\n                cleanPath = this._removeEmptyFolders(path);\n                _path = this._getFinalPath(cleanPath);\n                _context.next = 8;\n                return this.fetch(\"\".concat(this.url, \"/object/\").concat(_path), {\n                  method: method,\n                  body: body,\n                  headers: headers\n                });\n\n              case 8:\n                res = _context.sent;\n\n                if (!res.ok) {\n                  _context.next = 13;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  data: {\n                    Key: _path\n                  },\n                  error: null\n                });\n\n              case 13:\n                _context.next = 15;\n                return res.json();\n\n              case 15:\n                error = _context.sent;\n                return _context.abrupt(\"return\", {\n                  data: null,\n                  error: error\n                });\n\n              case 17:\n                _context.next = 22;\n                break;\n\n              case 19:\n                _context.prev = 19;\n                _context.t0 = _context[\"catch\"](0);\n                return _context.abrupt(\"return\", {\n                  data: null,\n                  error: _context.t0\n                });\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 19]]);\n      }));\n    }\n    /**\n     * Uploads a file to an existing bucket.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     * @param fileOptions HTTP headers.\n     * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n     * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n     * `upsert`: boolean, whether to perform an upsert.\n     */\n\n  }, {\n    key: \"upload\",\n    value: function upload(path, fileBody, fileOptions) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.uploadOrUpdate('POST', path, fileBody, fileOptions));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Replaces an existing file at the specified path with a new one.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     * @param fileOptions HTTP headers.\n     * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n     * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n     * `upsert`: boolean, whether to perform an upsert.\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(path, fileBody, fileOptions) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.uploadOrUpdate('PUT', path, fileBody, fileOptions));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Moves an existing file.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n     */\n\n  }, {\n    key: \"move\",\n    value: function move(fromPath, toPath) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                _context4.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/object/move\"), {\n                  bucketId: this.bucketId,\n                  sourceKey: fromPath,\n                  destinationKey: toPath\n                }, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context4.sent;\n                return _context4.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context4.prev = 7;\n                _context4.t0 = _context4[\"catch\"](0);\n                return _context4.abrupt(\"return\", {\n                  data: null,\n                  error: _context4.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Copies an existing file.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy(fromPath, toPath) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                _context5.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/object/copy\"), {\n                  bucketId: this.bucketId,\n                  sourceKey: fromPath,\n                  destinationKey: toPath\n                }, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context5.sent;\n                return _context5.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context5.prev = 7;\n                _context5.t0 = _context5[\"catch\"](0);\n                return _context5.abrupt(\"return\", {\n                  data: null,\n                  error: _context5.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Create signed URL to download file without requiring permissions. This URL can be valid for a set number of seconds.\n     *\n     * @param path The file path to be downloaded, including the current file name. For example `folder/image.png`.\n     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n     */\n\n  }, {\n    key: \"createSignedUrl\",\n    value: function createSignedUrl(path, expiresIn) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _path, data, signedURL;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n                _path = this._getFinalPath(path);\n                _context6.next = 4;\n                return post(this.fetch, \"\".concat(this.url, \"/object/sign/\").concat(_path), {\n                  expiresIn: expiresIn\n                }, {\n                  headers: this.headers\n                });\n\n              case 4:\n                data = _context6.sent;\n                signedURL = \"\".concat(this.url).concat(data.signedURL);\n                data = {\n                  signedURL: signedURL\n                };\n                return _context6.abrupt(\"return\", {\n                  data: data,\n                  error: null,\n                  signedURL: signedURL\n                });\n\n              case 10:\n                _context6.prev = 10;\n                _context6.t0 = _context6[\"catch\"](0);\n                return _context6.abrupt(\"return\", {\n                  data: null,\n                  error: _context6.t0,\n                  signedURL: null\n                });\n\n              case 13:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[0, 10]]);\n      }));\n    }\n    /**\n     * Create signed URLs to download files without requiring permissions. These URLs can be valid for a set number of seconds.\n     *\n     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n     */\n\n  }, {\n    key: \"createSignedUrls\",\n    value: function createSignedUrls(paths, expiresIn) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var _this = this;\n\n        var data;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                _context7.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/object/sign/\").concat(this.bucketId), {\n                  expiresIn: expiresIn,\n                  paths: paths\n                }, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context7.sent;\n                return _context7.abrupt(\"return\", {\n                  data: data.map(function (datum) {\n                    return Object.assign(Object.assign({}, datum), {\n                      signedURL: datum.signedURL ? \"\".concat(_this.url).concat(datum.signedURL) : null\n                    });\n                  }),\n                  error: null\n                });\n\n              case 7:\n                _context7.prev = 7;\n                _context7.t0 = _context7[\"catch\"](0);\n                return _context7.abrupt(\"return\", {\n                  data: null,\n                  error: _context7.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Downloads a file.\n     *\n     * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.\n     */\n\n  }, {\n    key: \"download\",\n    value: function download(path) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _path, res, data;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                _path = this._getFinalPath(path);\n                _context8.next = 4;\n                return get(this.fetch, \"\".concat(this.url, \"/object/\").concat(_path), {\n                  headers: this.headers,\n                  noResolveJson: true\n                });\n\n              case 4:\n                res = _context8.sent;\n                _context8.next = 7;\n                return res.blob();\n\n              case 7:\n                data = _context8.sent;\n                return _context8.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 11:\n                _context8.prev = 11;\n                _context8.t0 = _context8[\"catch\"](0);\n                return _context8.abrupt(\"return\", {\n                  data: null,\n                  error: _context8.t0\n                });\n\n              case 14:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 11]]);\n      }));\n    }\n    /**\n     * Retrieve URLs for assets in public buckets\n     *\n     * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.\n     */\n\n  }, {\n    key: \"getPublicUrl\",\n    value: function getPublicUrl(path) {\n      try {\n        var _path = this._getFinalPath(path);\n\n        var publicURL = \"\".concat(this.url, \"/object/public/\").concat(_path);\n        var data = {\n          publicURL: publicURL\n        };\n        return {\n          data: data,\n          error: null,\n          publicURL: publicURL\n        };\n      } catch (error) {\n        return {\n          data: null,\n          error: error,\n          publicURL: null\n        };\n      }\n    }\n    /**\n     * Deletes files within the same bucket\n     *\n     * @param paths An array of files to be deleted, including the path and file name. For example [`folder/image.png`].\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(paths) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                _context9.next = 3;\n                return _remove(this.fetch, \"\".concat(this.url, \"/object/\").concat(this.bucketId), {\n                  prefixes: paths\n                }, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context9.sent;\n                return _context9.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context9.prev = 7;\n                _context9.t0 = _context9[\"catch\"](0);\n                return _context9.abrupt(\"return\", {\n                  data: null,\n                  error: _context9.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Get file metadata\n     * @param id the file id to retrieve metadata\n     */\n    // async getMetadata(id: string): Promise<{ data: Metadata | null; error: Error | null }> {\n    //   try {\n    //     const data = await get(`${this.url}/metadata/${id}`, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     return { data: null, error }\n    //   }\n    // }\n\n    /**\n     * Update file metadata\n     * @param id the file id to update metadata\n     * @param meta the new file metadata\n     */\n    // async updateMetadata(\n    //   id: string,\n    //   meta: Metadata\n    // ): Promise<{ data: Metadata | null; error: Error | null }> {\n    //   try {\n    //     const data = await post(`${this.url}/metadata/${id}`, { ...meta }, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     return { data: null, error }\n    //   }\n    // }\n\n    /**\n     * Lists all the files within a bucket.\n     * @param path The folder path.\n     * @param options Search options, including `limit`, `offset`, and `sortBy`.\n     * @param parameters Fetch parameters, currently only supports `signal`, which is an AbortController's signal\n     */\n\n  }, {\n    key: \"list\",\n    value: function list(path, options, parameters) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var body, data;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.prev = 0;\n                body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), {\n                  prefix: path || ''\n                });\n                _context10.next = 4;\n                return post(this.fetch, \"\".concat(this.url, \"/object/list/\").concat(this.bucketId), body, {\n                  headers: this.headers\n                }, parameters);\n\n              case 4:\n                data = _context10.sent;\n                return _context10.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 8:\n                _context10.prev = 8;\n                _context10.t0 = _context10[\"catch\"](0);\n                return _context10.abrupt(\"return\", {\n                  data: null,\n                  error: _context10.t0\n                });\n\n              case 11:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[0, 8]]);\n      }));\n    }\n  }, {\n    key: \"_getFinalPath\",\n    value: function _getFinalPath(path) {\n      return \"\".concat(this.bucketId, \"/\").concat(path);\n    }\n  }, {\n    key: \"_removeEmptyFolders\",\n    value: function _removeEmptyFolders(path) {\n      return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/');\n    }\n  }]);\n\n  return StorageFileApi;\n}();","map":{"version":3,"sources":["../../../src/lib/StorageFileApi.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { get, post, remove } from './fetch';\nimport { resolveFetch } from './helpers';\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: 'name',\n        order: 'asc',\n    },\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: '3600',\n    contentType: 'text/plain;charset=UTF-8',\n    upsert: false,\n};\nexport class StorageFileApi {\n    constructor(url, headers = {}, bucketId, fetch) {\n        this.url = url;\n        this.headers = headers;\n        this.bucketId = bucketId;\n        this.fetch = resolveFetch(fetch);\n    }\n    /**\n     * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n     *\n     * @param method HTTP method.\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     * @param fileOptions HTTP headers.\n     * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n     * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n     * `upsert`: boolean, whether to perform an upsert.\n     */\n    uploadOrUpdate(method, path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let body;\n                const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);\n                const headers = Object.assign(Object.assign({}, this.headers), (method === 'POST' && { 'x-upsert': String(options.upsert) }));\n                if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n                    body = new FormData();\n                    body.append('cacheControl', options.cacheControl);\n                    body.append('', fileBody);\n                }\n                else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n                    body = fileBody;\n                    body.append('cacheControl', options.cacheControl);\n                }\n                else {\n                    body = fileBody;\n                    headers['cache-control'] = `max-age=${options.cacheControl}`;\n                    headers['content-type'] = options.contentType;\n                }\n                const cleanPath = this._removeEmptyFolders(path);\n                const _path = this._getFinalPath(cleanPath);\n                const res = yield this.fetch(`${this.url}/object/${_path}`, {\n                    method,\n                    body: body,\n                    headers,\n                });\n                if (res.ok) {\n                    // const data = await res.json()\n                    // temporary fix till backend is updated to the latest storage-api version\n                    return { data: { Key: _path }, error: null };\n                }\n                else {\n                    const error = yield res.json();\n                    return { data: null, error };\n                }\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Uploads a file to an existing bucket.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     * @param fileOptions HTTP headers.\n     * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n     * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n     * `upsert`: boolean, whether to perform an upsert.\n     */\n    upload(path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.uploadOrUpdate('POST', path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Replaces an existing file at the specified path with a new one.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     * @param fileOptions HTTP headers.\n     * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n     * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n     * `upsert`: boolean, whether to perform an upsert.\n     */\n    update(path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.uploadOrUpdate('PUT', path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Moves an existing file.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n     */\n    move(fromPath, toPath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/object/move`, { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Copies an existing file.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n     */\n    copy(fromPath, toPath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/object/copy`, { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Create signed URL to download file without requiring permissions. This URL can be valid for a set number of seconds.\n     *\n     * @param path The file path to be downloaded, including the current file name. For example `folder/image.png`.\n     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n     */\n    createSignedUrl(path, expiresIn) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const _path = this._getFinalPath(path);\n                let data = yield post(this.fetch, `${this.url}/object/sign/${_path}`, { expiresIn }, { headers: this.headers });\n                const signedURL = `${this.url}${data.signedURL}`;\n                data = { signedURL };\n                return { data, error: null, signedURL };\n            }\n            catch (error) {\n                return { data: null, error, signedURL: null };\n            }\n        });\n    }\n    /**\n     * Create signed URLs to download files without requiring permissions. These URLs can be valid for a set number of seconds.\n     *\n     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n     */\n    createSignedUrls(paths, expiresIn) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });\n                return {\n                    data: data.map((datum) => (Object.assign(Object.assign({}, datum), { signedURL: datum.signedURL ? `${this.url}${datum.signedURL}` : null }))),\n                    error: null,\n                };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Downloads a file.\n     *\n     * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.\n     */\n    download(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const _path = this._getFinalPath(path);\n                const res = yield get(this.fetch, `${this.url}/object/${_path}`, {\n                    headers: this.headers,\n                    noResolveJson: true,\n                });\n                const data = yield res.blob();\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Retrieve URLs for assets in public buckets\n     *\n     * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.\n     */\n    getPublicUrl(path) {\n        try {\n            const _path = this._getFinalPath(path);\n            const publicURL = `${this.url}/object/public/${_path}`;\n            const data = { publicURL };\n            return { data, error: null, publicURL };\n        }\n        catch (error) {\n            return { data: null, error, publicURL: null };\n        }\n    }\n    /**\n     * Deletes files within the same bucket\n     *\n     * @param paths An array of files to be deleted, including the path and file name. For example [`folder/image.png`].\n     */\n    remove(paths) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Get file metadata\n     * @param id the file id to retrieve metadata\n     */\n    // async getMetadata(id: string): Promise<{ data: Metadata | null; error: Error | null }> {\n    //   try {\n    //     const data = await get(`${this.url}/metadata/${id}`, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     return { data: null, error }\n    //   }\n    // }\n    /**\n     * Update file metadata\n     * @param id the file id to update metadata\n     * @param meta the new file metadata\n     */\n    // async updateMetadata(\n    //   id: string,\n    //   meta: Metadata\n    // ): Promise<{ data: Metadata | null; error: Error | null }> {\n    //   try {\n    //     const data = await post(`${this.url}/metadata/${id}`, { ...meta }, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     return { data: null, error }\n    //   }\n    // }\n    /**\n     * Lists all the files within a bucket.\n     * @param path The folder path.\n     * @param options Search options, including `limit`, `offset`, and `sortBy`.\n     * @param parameters Fetch parameters, currently only supports `signal`, which is an AbortController's signal\n     */\n    list(path, options, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || '' });\n                const data = yield post(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/');\n    }\n}\n//# sourceMappingURL=StorageFileApi.js.map"]},"metadata":{},"sourceType":"module"}