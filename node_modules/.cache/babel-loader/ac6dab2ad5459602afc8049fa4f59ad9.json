{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { get, post, put, remove } from './lib/fetch';\nimport { COOKIE_OPTIONS } from './lib/constants';\nimport { setCookies, getCookieString } from './lib/cookies';\nimport { expiresAt, resolveFetch } from './lib/helpers';\n\nvar GoTrueApi = /*#__PURE__*/function () {\n  function GoTrueApi(_ref) {\n    var _ref$url = _ref.url,\n        url = _ref$url === void 0 ? '' : _ref$url,\n        _ref$headers = _ref.headers,\n        headers = _ref$headers === void 0 ? {} : _ref$headers,\n        cookieOptions = _ref.cookieOptions,\n        fetch = _ref.fetch;\n\n    _classCallCheck(this, GoTrueApi);\n\n    this.url = url;\n    this.headers = headers;\n    this.cookieOptions = Object.assign(Object.assign({}, COOKIE_OPTIONS), cookieOptions);\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n\n\n  _createClass(GoTrueApi, [{\n    key: \"_createRequestHeaders\",\n    value: function _createRequestHeaders(jwt) {\n      var headers = Object.assign({}, this.headers);\n      headers['Authorization'] = \"Bearer \".concat(jwt);\n      return headers;\n    }\n  }, {\n    key: \"cookieName\",\n    value: function cookieName() {\n      var _a;\n\n      return (_a = this.cookieOptions.name) !== null && _a !== void 0 ? _a : '';\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n\n  }, {\n    key: \"getUrlForProvider\",\n    value: function getUrlForProvider(provider, options) {\n      var urlParams = [\"provider=\".concat(encodeURIComponent(provider))];\n\n      if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        urlParams.push(\"redirect_to=\".concat(encodeURIComponent(options.redirectTo)));\n      }\n\n      if (options === null || options === void 0 ? void 0 : options.scopes) {\n        urlParams.push(\"scopes=\".concat(encodeURIComponent(options.scopes)));\n      }\n\n      return \"\".concat(this.url, \"/authorize?\").concat(urlParams.join('&'));\n    }\n    /**\n     * Creates a new user using their email address.\n     * @param email The email address of the user.\n     * @param password The password of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param data Optional user metadata.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n\n  }, {\n    key: \"signUpWithEmail\",\n    value: function signUpWithEmail(email, password) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var headers, queryString, data, session;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '';\n\n                if (options.redirectTo) {\n                  queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n\n                _context.next = 6;\n                return post(this.fetch, \"\".concat(this.url, \"/signup\").concat(queryString), {\n                  email: email,\n                  password: password,\n                  data: options.data,\n                  gotrue_meta_security: {\n                    hcaptcha_token: options.captchaToken\n                  }\n                }, {\n                  headers: headers\n                });\n\n              case 6:\n                data = _context.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](0);\n                return _context.abrupt(\"return\", {\n                  data: null,\n                  error: _context.t0\n                });\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 12]]);\n      }));\n    }\n    /**\n     * Logs in an existing user using their email address.\n     * @param email The email address of the user.\n     * @param password The password of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n\n  }, {\n    key: \"signInWithEmail\",\n    value: function signInWithEmail(email, password) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var headers, queryString, data, session;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '?grant_type=password';\n\n                if (options.redirectTo) {\n                  queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n\n                _context2.next = 6;\n                return post(this.fetch, \"\".concat(this.url, \"/token\").concat(queryString), {\n                  email: email,\n                  password: password\n                }, {\n                  headers: headers\n                });\n\n              case 6:\n                data = _context2.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context2.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 12:\n                _context2.prev = 12;\n                _context2.t0 = _context2[\"catch\"](0);\n                return _context2.abrupt(\"return\", {\n                  data: null,\n                  error: _context2.t0\n                });\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 12]]);\n      }));\n    }\n    /**\n     * Signs up a new user using their phone number and a password.\n     * @param phone The phone number of the user.\n     * @param password The password of the user.\n     * @param data Optional user metadata.\n     */\n\n  }, {\n    key: \"signUpWithPhone\",\n    value: function signUpWithPhone(phone, password) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var headers, data, session;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                headers = Object.assign({}, this.headers);\n                _context3.next = 4;\n                return post(this.fetch, \"\".concat(this.url, \"/signup\"), {\n                  phone: phone,\n                  password: password,\n                  data: options.data,\n                  gotrue_meta_security: {\n                    hcaptcha_token: options.captchaToken\n                  }\n                }, {\n                  headers: headers\n                });\n\n              case 4:\n                data = _context3.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context3.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 10:\n                _context3.prev = 10;\n                _context3.t0 = _context3[\"catch\"](0);\n                return _context3.abrupt(\"return\", {\n                  data: null,\n                  error: _context3.t0\n                });\n\n              case 13:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 10]]);\n      }));\n    }\n    /**\n     * Logs in an existing user using their phone number and password.\n     * @param phone The phone number of the user.\n     * @param password The password of the user.\n     */\n\n  }, {\n    key: \"signInWithPhone\",\n    value: function signInWithPhone(phone, password) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var headers, queryString, data, session;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '?grant_type=password';\n                _context4.next = 5;\n                return post(this.fetch, \"\".concat(this.url, \"/token\").concat(queryString), {\n                  phone: phone,\n                  password: password\n                }, {\n                  headers: headers\n                });\n\n              case 5:\n                data = _context4.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context4.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 11:\n                _context4.prev = 11;\n                _context4.t0 = _context4[\"catch\"](0);\n                return _context4.abrupt(\"return\", {\n                  data: null,\n                  error: _context4.t0\n                });\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 11]]);\n      }));\n    }\n    /**\n     * Logs in an OpenID Connect user using their id_token.\n     * @param id_token The IDToken of the user.\n     * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n     * @param provider The provider of the user.\n     * @param client_id The clientID of the user.\n     * @param issuer The issuer of the user.\n     */\n\n  }, {\n    key: \"signInWithOpenIDConnect\",\n    value: function signInWithOpenIDConnect(_ref2) {\n      var id_token = _ref2.id_token,\n          nonce = _ref2.nonce,\n          client_id = _ref2.client_id,\n          issuer = _ref2.issuer,\n          provider = _ref2.provider;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var headers, queryString, data, session;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '?grant_type=id_token';\n                _context5.next = 5;\n                return post(this.fetch, \"\".concat(this.url, \"/token\").concat(queryString), {\n                  id_token: id_token,\n                  nonce: nonce,\n                  client_id: client_id,\n                  issuer: issuer,\n                  provider: provider\n                }, {\n                  headers: headers\n                });\n\n              case 5:\n                data = _context5.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context5.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 11:\n                _context5.prev = 11;\n                _context5.t0 = _context5[\"catch\"](0);\n                return _context5.abrupt(\"return\", {\n                  data: null,\n                  error: _context5.t0\n                });\n\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 11]]);\n      }));\n    }\n    /**\n     * Sends a magic login link to an email address.\n     * @param email The email address of the user.\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n\n  }, {\n    key: \"sendMagicLinkEmail\",\n    value: function sendMagicLinkEmail(email) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var headers, queryString, shouldCreateUser, data;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '';\n\n                if (options.redirectTo) {\n                  queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n\n                shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n                _context6.next = 7;\n                return post(this.fetch, \"\".concat(this.url, \"/otp\").concat(queryString), {\n                  email: email,\n                  create_user: shouldCreateUser,\n                  gotrue_meta_security: {\n                    hcaptcha_token: options.captchaToken\n                  }\n                }, {\n                  headers: headers\n                });\n\n              case 7:\n                data = _context6.sent;\n                return _context6.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 11:\n                _context6.prev = 11;\n                _context6.t0 = _context6[\"catch\"](0);\n                return _context6.abrupt(\"return\", {\n                  data: null,\n                  error: _context6.t0\n                });\n\n              case 14:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[0, 11]]);\n      }));\n    }\n    /**\n     * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n     * @param phone The user's phone number WITH international prefix\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     */\n\n  }, {\n    key: \"sendMobileOTP\",\n    value: function sendMobileOTP(phone) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var shouldCreateUser, headers, data;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n                headers = Object.assign({}, this.headers);\n                _context7.next = 5;\n                return post(this.fetch, \"\".concat(this.url, \"/otp\"), {\n                  phone: phone,\n                  create_user: shouldCreateUser,\n                  gotrue_meta_security: {\n                    hcaptcha_token: options.captchaToken\n                  }\n                }, {\n                  headers: headers\n                });\n\n              case 5:\n                data = _context7.sent;\n                return _context7.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 9:\n                _context7.prev = 9;\n                _context7.t0 = _context7[\"catch\"](0);\n                return _context7.abrupt(\"return\", {\n                  data: null,\n                  error: _context7.t0\n                });\n\n              case 12:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 9]]);\n      }));\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     */\n\n  }, {\n    key: \"signOut\",\n    value: function signOut(jwt) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                _context8.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/logout\"), {}, {\n                  headers: this._createRequestHeaders(jwt),\n                  noResolveJson: true\n                });\n\n              case 3:\n                return _context8.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 6:\n                _context8.prev = 6;\n                _context8.t0 = _context8[\"catch\"](0);\n                return _context8.abrupt(\"return\", {\n                  error: _context8.t0\n                });\n\n              case 9:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 6]]);\n      }));\n    }\n    /**\n     * @deprecated Use `verifyOTP` instead!\n     * @param phone The user's phone number WITH international prefix\n     * @param token token that user was sent to their mobile phone\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n\n  }, {\n    key: \"verifyMobileOTP\",\n    value: function verifyMobileOTP(phone, token) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var headers, data, session;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                headers = Object.assign({}, this.headers);\n                _context9.next = 4;\n                return post(this.fetch, \"\".concat(this.url, \"/verify\"), {\n                  phone: phone,\n                  token: token,\n                  type: 'sms',\n                  redirect_to: options.redirectTo\n                }, {\n                  headers: headers\n                });\n\n              case 4:\n                data = _context9.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context9.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 10:\n                _context9.prev = 10;\n                _context9.t0 = _context9[\"catch\"](0);\n                return _context9.abrupt(\"return\", {\n                  data: null,\n                  error: _context9.t0\n                });\n\n              case 13:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 10]]);\n      }));\n    }\n    /**\n     * Send User supplied Email / Mobile OTP to be verified\n     * @param email The user's email address\n     * @param phone The user's phone number WITH international prefix\n     * @param token token that user was sent to their mobile phone\n     * @param type verification type that the otp is generated for\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n\n  }, {\n    key: \"verifyOTP\",\n    value: function verifyOTP(_ref3) {\n      var email = _ref3.email,\n          phone = _ref3.phone,\n          token = _ref3.token,\n          _ref3$type = _ref3.type,\n          type = _ref3$type === void 0 ? 'sms' : _ref3$type;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var headers, data, session;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.prev = 0;\n                headers = Object.assign({}, this.headers);\n                _context10.next = 4;\n                return post(this.fetch, \"\".concat(this.url, \"/verify\"), {\n                  email: email,\n                  phone: phone,\n                  token: token,\n                  type: type,\n                  redirect_to: options.redirectTo\n                }, {\n                  headers: headers\n                });\n\n              case 4:\n                data = _context10.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context10.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 10:\n                _context10.prev = 10;\n                _context10.t0 = _context10[\"catch\"](0);\n                return _context10.abrupt(\"return\", {\n                  data: null,\n                  error: _context10.t0\n                });\n\n              case 13:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[0, 10]]);\n      }));\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param data Optional user metadata\n     */\n\n  }, {\n    key: \"inviteUserByEmail\",\n    value: function inviteUserByEmail(email) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var headers, queryString, data;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '';\n\n                if (options.redirectTo) {\n                  queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n\n                _context11.next = 6;\n                return post(this.fetch, \"\".concat(this.url, \"/invite\").concat(queryString), {\n                  email: email,\n                  data: options.data\n                }, {\n                  headers: headers\n                });\n\n              case 6:\n                data = _context11.sent;\n                return _context11.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 10:\n                _context11.prev = 10;\n                _context11.t0 = _context11[\"catch\"](0);\n                return _context11.abrupt(\"return\", {\n                  data: null,\n                  error: _context11.t0\n                });\n\n              case 13:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[0, 10]]);\n      }));\n    }\n    /**\n     * Sends a reset request to an email address.\n     * @param email The email address of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n\n  }, {\n    key: \"resetPasswordForEmail\",\n    value: function resetPasswordForEmail(email) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var headers, queryString, data;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '';\n\n                if (options.redirectTo) {\n                  queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n\n                _context12.next = 6;\n                return post(this.fetch, \"\".concat(this.url, \"/recover\").concat(queryString), {\n                  email: email,\n                  gotrue_meta_security: {\n                    hcaptcha_token: options.captchaToken\n                  }\n                }, {\n                  headers: headers\n                });\n\n              case 6:\n                data = _context12.sent;\n                return _context12.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 10:\n                _context12.prev = 10;\n                _context12.t0 = _context12[\"catch\"](0);\n                return _context12.abrupt(\"return\", {\n                  data: null,\n                  error: _context12.t0\n                });\n\n              case 13:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[0, 10]]);\n      }));\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n\n  }, {\n    key: \"refreshAccessToken\",\n    value: function refreshAccessToken(refreshToken) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var data, session;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.prev = 0;\n                _context13.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/token?grant_type=refresh_token\"), {\n                  refresh_token: refreshToken\n                }, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context13.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context13.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 9:\n                _context13.prev = 9;\n                _context13.t0 = _context13[\"catch\"](0);\n                return _context13.abrupt(\"return\", {\n                  data: null,\n                  error: _context13.t0\n                });\n\n              case 12:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[0, 9]]);\n      }));\n    }\n    /**\n     * Set/delete the auth cookie based on the AuthChangeEvent.\n     * Works for Next.js & Express (requires cookie-parser middleware).\n     * @param req The request object.\n     * @param res The response object.\n     */\n\n  }, {\n    key: \"setAuthCookie\",\n    value: function setAuthCookie(req, res) {\n      var _this = this;\n\n      if (req.method !== 'POST') {\n        res.setHeader('Allow', 'POST');\n        res.status(405).end('Method Not Allowed');\n      }\n\n      var _req$body = req.body,\n          event = _req$body.event,\n          session = _req$body.session;\n      if (!event) throw new Error('Auth event missing!');\n\n      if (event === 'SIGNED_IN') {\n        if (!session) throw new Error('Auth session missing!');\n        setCookies(req, res, [{\n          key: 'access-token',\n          value: session.access_token\n        }, {\n          key: 'refresh-token',\n          value: session.refresh_token\n        }].map(function (token) {\n          var _a;\n\n          return {\n            name: \"\".concat(_this.cookieName(), \"-\").concat(token.key),\n            value: token.value,\n            domain: _this.cookieOptions.domain,\n            maxAge: (_a = _this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n            path: _this.cookieOptions.path,\n            sameSite: _this.cookieOptions.sameSite\n          };\n        }));\n      }\n\n      if (event === 'SIGNED_OUT') {\n        setCookies(req, res, ['access-token', 'refresh-token'].map(function (key) {\n          return {\n            name: \"\".concat(_this.cookieName(), \"-\").concat(key),\n            value: '',\n            maxAge: -1\n          };\n        }));\n      }\n\n      res.status(200).json({});\n    }\n    /**\n     * Deletes the Auth Cookies and redirects to the\n     * @param req The request object.\n     * @param res The response object.\n     * @param options Optionally specify a `redirectTo` URL in the options.\n     */\n\n  }, {\n    key: \"deleteAuthCookie\",\n    value: function deleteAuthCookie(req, res, _ref4) {\n      var _this2 = this;\n\n      var _ref4$redirectTo = _ref4.redirectTo,\n          redirectTo = _ref4$redirectTo === void 0 ? '/' : _ref4$redirectTo;\n      setCookies(req, res, ['access-token', 'refresh-token'].map(function (key) {\n        return {\n          name: \"\".concat(_this2.cookieName(), \"-\").concat(key),\n          value: '',\n          maxAge: -1\n        };\n      }));\n      return res.redirect(307, redirectTo);\n    }\n    /**\n     * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n     * @param req The request object.\n     * @param res The response object.\n     * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n     */\n\n  }, {\n    key: \"getAuthCookieString\",\n    value: function getAuthCookieString(req, res) {\n      var _this3 = this;\n\n      if (req.method !== 'POST') {\n        res.setHeader('Allow', 'POST');\n        res.status(405).end('Method Not Allowed');\n      }\n\n      var _req$body2 = req.body,\n          event = _req$body2.event,\n          session = _req$body2.session;\n      if (!event) throw new Error('Auth event missing!');\n\n      if (event === 'SIGNED_IN') {\n        if (!session) throw new Error('Auth session missing!');\n        return getCookieString(req, res, [{\n          key: 'access-token',\n          value: session.access_token\n        }, {\n          key: 'refresh-token',\n          value: session.refresh_token\n        }].map(function (token) {\n          var _a;\n\n          return {\n            name: \"\".concat(_this3.cookieName(), \"-\").concat(token.key),\n            value: token.value,\n            domain: _this3.cookieOptions.domain,\n            maxAge: (_a = _this3.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n            path: _this3.cookieOptions.path,\n            sameSite: _this3.cookieOptions.sameSite\n          };\n        }));\n      }\n\n      if (event === 'SIGNED_OUT') {\n        return getCookieString(req, res, ['access-token', 'refresh-token'].map(function (key) {\n          return {\n            name: \"\".concat(_this3.cookieName(), \"-\").concat(key),\n            value: '',\n            maxAge: -1\n          };\n        }));\n      }\n\n      return res.getHeader('Set-Cookie');\n    }\n    /**\n     * Generates links to be sent via email or other.\n     * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n     * @param email The user's email.\n     * @param password User password. For signup only.\n     * @param data Optional user metadata. For signup only.\n     * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n     */\n\n  }, {\n    key: \"generateLink\",\n    value: function generateLink(type, email) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.prev = 0;\n                _context14.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/admin/generate_link\"), {\n                  type: type,\n                  email: email,\n                  password: options.password,\n                  data: options.data,\n                  redirect_to: options.redirectTo\n                }, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context14.sent;\n                return _context14.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context14.prev = 7;\n                _context14.t0 = _context14[\"catch\"](0);\n                return _context14.abrupt(\"return\", {\n                  data: null,\n                  error: _context14.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this, [[0, 7]]);\n      }));\n    } // User Admin API\n\n    /**\n     * Creates a new user.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     *\n     * @param attributes The data you want to create the user with.\n     */\n\n  }, {\n    key: \"createUser\",\n    value: function createUser(attributes) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.prev = 0;\n                _context15.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/admin/users\"), attributes, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context15.sent;\n                return _context15.abrupt(\"return\", {\n                  user: data,\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context15.prev = 7;\n                _context15.t0 = _context15[\"catch\"](0);\n                return _context15.abrupt(\"return\", {\n                  user: null,\n                  data: null,\n                  error: _context15.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n\n  }, {\n    key: \"listUsers\",\n    value: function listUsers() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.prev = 0;\n                _context16.next = 3;\n                return get(this.fetch, \"\".concat(this.url, \"/admin/users\"), {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context16.sent;\n                return _context16.abrupt(\"return\", {\n                  data: data.users,\n                  error: null\n                });\n\n              case 7:\n                _context16.prev = 7;\n                _context16.t0 = _context16[\"catch\"](0);\n                return _context16.abrupt(\"return\", {\n                  data: null,\n                  error: _context16.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n\n  }, {\n    key: \"getUserById\",\n    value: function getUserById(uid) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.prev = 0;\n                _context17.next = 3;\n                return get(this.fetch, \"\".concat(this.url, \"/admin/users/\").concat(uid), {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context17.sent;\n                return _context17.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context17.prev = 7;\n                _context17.t0 = _context17[\"catch\"](0);\n                return _context17.abrupt(\"return\", {\n                  data: null,\n                  error: _context17.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Get user by reading the cookie from the request.\n     * Works for Next.js & Express (requires cookie-parser middleware).\n     */\n\n  }, {\n    key: \"getUserByCookie\",\n    value: function getUserByCookie(req, res) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var _this4 = this;\n\n        var access_token, refresh_token, _yield$this$getUser, user, getUserError, _yield$this$refreshAc, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.prev = 0;\n\n                if (req.cookies) {\n                  _context18.next = 3;\n                  break;\n                }\n\n                throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');\n\n              case 3:\n                access_token = req.cookies[\"\".concat(this.cookieName(), \"-access-token\")];\n                refresh_token = req.cookies[\"\".concat(this.cookieName(), \"-refresh-token\")];\n\n                if (access_token) {\n                  _context18.next = 7;\n                  break;\n                }\n\n                throw new Error('No cookie found!');\n\n              case 7:\n                _context18.next = 9;\n                return this.getUser(access_token);\n\n              case 9:\n                _yield$this$getUser = _context18.sent;\n                user = _yield$this$getUser.user;\n                getUserError = _yield$this$getUser.error;\n\n                if (!getUserError) {\n                  _context18.next = 29;\n                  break;\n                }\n\n                if (refresh_token) {\n                  _context18.next = 15;\n                  break;\n                }\n\n                throw new Error('No refresh_token cookie found!');\n\n              case 15:\n                if (res) {\n                  _context18.next = 17;\n                  break;\n                }\n\n                throw new Error('You need to pass the res object to automatically refresh the session!');\n\n              case 17:\n                _context18.next = 19;\n                return this.refreshAccessToken(refresh_token);\n\n              case 19:\n                _yield$this$refreshAc = _context18.sent;\n                data = _yield$this$refreshAc.data;\n                error = _yield$this$refreshAc.error;\n\n                if (!error) {\n                  _context18.next = 26;\n                  break;\n                }\n\n                throw error;\n\n              case 26:\n                if (!data) {\n                  _context18.next = 29;\n                  break;\n                }\n\n                setCookies(req, res, [{\n                  key: 'access-token',\n                  value: data.access_token\n                }, {\n                  key: 'refresh-token',\n                  value: data.refresh_token\n                }].map(function (token) {\n                  var _a;\n\n                  return {\n                    name: \"\".concat(_this4.cookieName(), \"-\").concat(token.key),\n                    value: token.value,\n                    domain: _this4.cookieOptions.domain,\n                    maxAge: (_a = _this4.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                    path: _this4.cookieOptions.path,\n                    sameSite: _this4.cookieOptions.sameSite\n                  };\n                }));\n                return _context18.abrupt(\"return\", {\n                  token: data.access_token,\n                  user: data.user,\n                  data: data.user,\n                  error: null\n                });\n\n              case 29:\n                return _context18.abrupt(\"return\", {\n                  token: access_token,\n                  user: user,\n                  data: user,\n                  error: null\n                });\n\n              case 32:\n                _context18.prev = 32;\n                _context18.t0 = _context18[\"catch\"](0);\n                return _context18.abrupt(\"return\", {\n                  token: null,\n                  user: null,\n                  data: null,\n                  error: _context18.t0\n                });\n\n              case 35:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this, [[0, 32]]);\n      }));\n    }\n    /**\n     * Updates the user data.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n\n  }, {\n    key: \"updateUserById\",\n    value: function updateUserById(uid, attributes) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.prev = 0;\n                this; //\n\n                _context19.next = 4;\n                return put(this.fetch, \"\".concat(this.url, \"/admin/users/\").concat(uid), attributes, {\n                  headers: this.headers\n                });\n\n              case 4:\n                data = _context19.sent;\n                return _context19.abrupt(\"return\", {\n                  user: data,\n                  data: data,\n                  error: null\n                });\n\n              case 8:\n                _context19.prev = 8;\n                _context19.t0 = _context19[\"catch\"](0);\n                return _context19.abrupt(\"return\", {\n                  user: null,\n                  data: null,\n                  error: _context19.t0\n                });\n\n              case 11:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this, [[0, 8]]);\n      }));\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     *\n     * @param uid The user uid you want to remove.\n     */\n\n  }, {\n    key: \"deleteUser\",\n    value: function deleteUser(uid) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.prev = 0;\n                _context20.next = 3;\n                return remove(this.fetch, \"\".concat(this.url, \"/admin/users/\").concat(uid), {}, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context20.sent;\n                return _context20.abrupt(\"return\", {\n                  user: data,\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context20.prev = 7;\n                _context20.t0 = _context20[\"catch\"](0);\n                return _context20.abrupt(\"return\", {\n                  user: null,\n                  data: null,\n                  error: _context20.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Gets the current user details.\n     *\n     * This method is called by the GoTrueClient `update` where\n     * the jwt is set to this.currentSession.access_token\n     * and therefore, acts like getting the currently authenticated used\n     *\n     * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function getUser(jwt) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.prev = 0;\n                _context21.next = 3;\n                return get(this.fetch, \"\".concat(this.url, \"/user\"), {\n                  headers: this._createRequestHeaders(jwt)\n                });\n\n              case 3:\n                data = _context21.sent;\n                return _context21.abrupt(\"return\", {\n                  user: data,\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context21.prev = 7;\n                _context21.t0 = _context21[\"catch\"](0);\n                return _context21.abrupt(\"return\", {\n                  user: null,\n                  data: null,\n                  error: _context21.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Updates the user data.\n     * @param jwt A valid, logged-in JWT.\n     * @param attributes The data you want to update.\n     */\n\n  }, {\n    key: \"updateUser\",\n    value: function updateUser(jwt, attributes) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _context22.prev = 0;\n                _context22.next = 3;\n                return put(this.fetch, \"\".concat(this.url, \"/user\"), attributes, {\n                  headers: this._createRequestHeaders(jwt)\n                });\n\n              case 3:\n                data = _context22.sent;\n                return _context22.abrupt(\"return\", {\n                  user: data,\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context22.prev = 7;\n                _context22.t0 = _context22[\"catch\"](0);\n                return _context22.abrupt(\"return\", {\n                  user: null,\n                  data: null,\n                  error: _context22.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this, [[0, 7]]);\n      }));\n    }\n  }]);\n\n  return GoTrueApi;\n}();\n\nexport { GoTrueApi as default };","map":{"version":3,"sources":["../../src/GoTrueApi.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { get, post, put, remove } from './lib/fetch';\nimport { COOKIE_OPTIONS } from './lib/constants';\nimport { setCookies, getCookieString } from './lib/cookies';\nimport { expiresAt, resolveFetch } from './lib/helpers';\nexport default class GoTrueApi {\n    constructor({ url = '', headers = {}, cookieOptions, fetch, }) {\n        this.url = url;\n        this.headers = headers;\n        this.cookieOptions = Object.assign(Object.assign({}, COOKIE_OPTIONS), cookieOptions);\n        this.fetch = resolveFetch(fetch);\n    }\n    /**\n     * Create a temporary object with all configured headers and\n     * adds the Authorization token to be used on request methods\n     * @param jwt A valid, logged-in JWT.\n     */\n    _createRequestHeaders(jwt) {\n        const headers = Object.assign({}, this.headers);\n        headers['Authorization'] = `Bearer ${jwt}`;\n        return headers;\n    }\n    cookieName() {\n        var _a;\n        return (_a = this.cookieOptions.name) !== null && _a !== void 0 ? _a : '';\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n    getUrlForProvider(provider, options) {\n        const urlParams = [`provider=${encodeURIComponent(provider)}`];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        }\n        return `${this.url}/authorize?${urlParams.join('&')}`;\n    }\n    /**\n     * Creates a new user using their email address.\n     * @param email The email address of the user.\n     * @param password The password of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param data Optional user metadata.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n    signUpWithEmail(email, password, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) {\n                    queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const data = yield post(this.fetch, `${this.url}/signup${queryString}`, {\n                    email,\n                    password,\n                    data: options.data,\n                    gotrue_meta_security: { hcaptcha_token: options.captchaToken },\n                }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Logs in an existing user using their email address.\n     * @param email The email address of the user.\n     * @param password The password of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    signInWithEmail(email, password, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '?grant_type=password';\n                if (options.redirectTo) {\n                    queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const data = yield post(this.fetch, `${this.url}/token${queryString}`, { email, password }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Signs up a new user using their phone number and a password.\n     * @param phone The phone number of the user.\n     * @param password The password of the user.\n     * @param data Optional user metadata.\n     */\n    signUpWithPhone(phone, password, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const data = yield post(this.fetch, `${this.url}/signup`, {\n                    phone,\n                    password,\n                    data: options.data,\n                    gotrue_meta_security: { hcaptcha_token: options.captchaToken },\n                }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Logs in an existing user using their phone number and password.\n     * @param phone The phone number of the user.\n     * @param password The password of the user.\n     */\n    signInWithPhone(phone, password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const queryString = '?grant_type=password';\n                const data = yield post(this.fetch, `${this.url}/token${queryString}`, { phone, password }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Logs in an OpenID Connect user using their id_token.\n     * @param id_token The IDToken of the user.\n     * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n     * @param provider The provider of the user.\n     * @param client_id The clientID of the user.\n     * @param issuer The issuer of the user.\n     */\n    signInWithOpenIDConnect({ id_token, nonce, client_id, issuer, provider, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const queryString = '?grant_type=id_token';\n                const data = yield post(this.fetch, `${this.url}/token${queryString}`, { id_token, nonce, client_id, issuer, provider }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sends a magic login link to an email address.\n     * @param email The email address of the user.\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    sendMagicLinkEmail(email, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) {\n                    queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n                const data = yield post(this.fetch, `${this.url}/otp${queryString}`, {\n                    email,\n                    create_user: shouldCreateUser,\n                    gotrue_meta_security: { hcaptcha_token: options.captchaToken },\n                }, { headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n     * @param phone The user's phone number WITH international prefix\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     */\n    sendMobileOTP(phone, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n                const headers = Object.assign({}, this.headers);\n                const data = yield post(this.fetch, `${this.url}/otp`, {\n                    phone,\n                    create_user: shouldCreateUser,\n                    gotrue_meta_security: { hcaptcha_token: options.captchaToken },\n                }, { headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     */\n    signOut(jwt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield post(this.fetch, `${this.url}/logout`, {}, { headers: this._createRequestHeaders(jwt), noResolveJson: true });\n                return { error: null };\n            }\n            catch (e) {\n                return { error: e };\n            }\n        });\n    }\n    /**\n     * @deprecated Use `verifyOTP` instead!\n     * @param phone The user's phone number WITH international prefix\n     * @param token token that user was sent to their mobile phone\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    verifyMobileOTP(phone, token, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const data = yield post(this.fetch, `${this.url}/verify`, { phone, token, type: 'sms', redirect_to: options.redirectTo }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Send User supplied Email / Mobile OTP to be verified\n     * @param email The user's email address\n     * @param phone The user's phone number WITH international prefix\n     * @param token token that user was sent to their mobile phone\n     * @param type verification type that the otp is generated for\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    verifyOTP({ email, phone, token, type = 'sms' }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const data = yield post(this.fetch, `${this.url}/verify`, { email, phone, token, type, redirect_to: options.redirectTo }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param data Optional user metadata\n     */\n    inviteUserByEmail(email, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) {\n                    queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const data = yield post(this.fetch, `${this.url}/invite${queryString}`, { email, data: options.data }, { headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sends a reset request to an email address.\n     * @param email The email address of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    resetPasswordForEmail(email, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) {\n                    queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const data = yield post(this.fetch, `${this.url}/recover${queryString}`, { email, gotrue_meta_security: { hcaptcha_token: options.captchaToken } }, { headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n    refreshAccessToken(refreshToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/token?grant_type=refresh_token`, { refresh_token: refreshToken }, { headers: this.headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Set/delete the auth cookie based on the AuthChangeEvent.\n     * Works for Next.js & Express (requires cookie-parser middleware).\n     * @param req The request object.\n     * @param res The response object.\n     */\n    setAuthCookie(req, res) {\n        if (req.method !== 'POST') {\n            res.setHeader('Allow', 'POST');\n            res.status(405).end('Method Not Allowed');\n        }\n        const { event, session } = req.body;\n        if (!event)\n            throw new Error('Auth event missing!');\n        if (event === 'SIGNED_IN') {\n            if (!session)\n                throw new Error('Auth session missing!');\n            setCookies(req, res, [\n                { key: 'access-token', value: session.access_token },\n                { key: 'refresh-token', value: session.refresh_token },\n            ].map((token) => {\n                var _a;\n                return ({\n                    name: `${this.cookieName()}-${token.key}`,\n                    value: token.value,\n                    domain: this.cookieOptions.domain,\n                    maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                    path: this.cookieOptions.path,\n                    sameSite: this.cookieOptions.sameSite,\n                });\n            }));\n        }\n        if (event === 'SIGNED_OUT') {\n            setCookies(req, res, ['access-token', 'refresh-token'].map((key) => ({\n                name: `${this.cookieName()}-${key}`,\n                value: '',\n                maxAge: -1,\n            })));\n        }\n        res.status(200).json({});\n    }\n    /**\n     * Deletes the Auth Cookies and redirects to the\n     * @param req The request object.\n     * @param res The response object.\n     * @param options Optionally specify a `redirectTo` URL in the options.\n     */\n    deleteAuthCookie(req, res, { redirectTo = '/' }) {\n        setCookies(req, res, ['access-token', 'refresh-token'].map((key) => ({\n            name: `${this.cookieName()}-${key}`,\n            value: '',\n            maxAge: -1,\n        })));\n        return res.redirect(307, redirectTo);\n    }\n    /**\n     * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n     * @param req The request object.\n     * @param res The response object.\n     * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n     */\n    getAuthCookieString(req, res) {\n        if (req.method !== 'POST') {\n            res.setHeader('Allow', 'POST');\n            res.status(405).end('Method Not Allowed');\n        }\n        const { event, session } = req.body;\n        if (!event)\n            throw new Error('Auth event missing!');\n        if (event === 'SIGNED_IN') {\n            if (!session)\n                throw new Error('Auth session missing!');\n            return getCookieString(req, res, [\n                { key: 'access-token', value: session.access_token },\n                { key: 'refresh-token', value: session.refresh_token },\n            ].map((token) => {\n                var _a;\n                return ({\n                    name: `${this.cookieName()}-${token.key}`,\n                    value: token.value,\n                    domain: this.cookieOptions.domain,\n                    maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                    path: this.cookieOptions.path,\n                    sameSite: this.cookieOptions.sameSite,\n                });\n            }));\n        }\n        if (event === 'SIGNED_OUT') {\n            return getCookieString(req, res, ['access-token', 'refresh-token'].map((key) => ({\n                name: `${this.cookieName()}-${key}`,\n                value: '',\n                maxAge: -1,\n            })));\n        }\n        return res.getHeader('Set-Cookie');\n    }\n    /**\n     * Generates links to be sent via email or other.\n     * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n     * @param email The user's email.\n     * @param password User password. For signup only.\n     * @param data Optional user metadata. For signup only.\n     * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n     */\n    generateLink(type, email, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/admin/generate_link`, {\n                    type,\n                    email,\n                    password: options.password,\n                    data: options.data,\n                    redirect_to: options.redirectTo,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    // User Admin API\n    /**\n     * Creates a new user.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     *\n     * @param attributes The data you want to create the user with.\n     */\n    createUser(attributes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/admin/users`, attributes, {\n                    headers: this.headers,\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    listUsers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/admin/users`, {\n                    headers: this.headers,\n                });\n                return { data: data.users, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    getUserById(uid) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/admin/users/${uid}`, {\n                    headers: this.headers,\n                });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Get user by reading the cookie from the request.\n     * Works for Next.js & Express (requires cookie-parser middleware).\n     */\n    getUserByCookie(req, res) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!req.cookies) {\n                    throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');\n                }\n                const access_token = req.cookies[`${this.cookieName()}-access-token`];\n                const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`];\n                if (!access_token) {\n                    throw new Error('No cookie found!');\n                }\n                const { user, error: getUserError } = yield this.getUser(access_token);\n                if (getUserError) {\n                    if (!refresh_token)\n                        throw new Error('No refresh_token cookie found!');\n                    if (!res)\n                        throw new Error('You need to pass the res object to automatically refresh the session!');\n                    const { data, error } = yield this.refreshAccessToken(refresh_token);\n                    if (error) {\n                        throw error;\n                    }\n                    else if (data) {\n                        setCookies(req, res, [\n                            { key: 'access-token', value: data.access_token },\n                            { key: 'refresh-token', value: data.refresh_token },\n                        ].map((token) => {\n                            var _a;\n                            return ({\n                                name: `${this.cookieName()}-${token.key}`,\n                                value: token.value,\n                                domain: this.cookieOptions.domain,\n                                maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                                path: this.cookieOptions.path,\n                                sameSite: this.cookieOptions.sameSite,\n                            });\n                        }));\n                        return { token: data.access_token, user: data.user, data: data.user, error: null };\n                    }\n                }\n                return { token: access_token, user: user, data: user, error: null };\n            }\n            catch (e) {\n                return { token: null, user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Updates the user data.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    updateUserById(uid, attributes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this; //\n                const data = yield put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n                    headers: this.headers,\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     *\n     * @param uid The user uid you want to remove.\n     */\n    deleteUser(uid) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield remove(this.fetch, `${this.url}/admin/users/${uid}`, {}, {\n                    headers: this.headers,\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Gets the current user details.\n     *\n     * This method is called by the GoTrueClient `update` where\n     * the jwt is set to this.currentSession.access_token\n     * and therefore, acts like getting the currently authenticated used\n     *\n     * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n     */\n    getUser(jwt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/user`, {\n                    headers: this._createRequestHeaders(jwt),\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Updates the user data.\n     * @param jwt A valid, logged-in JWT.\n     * @param attributes The data you want to update.\n     */\n    updateUser(jwt, attributes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield put(this.fetch, `${this.url}/user`, attributes, {\n                    headers: this._createRequestHeaders(jwt),\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n}\n//# sourceMappingURL=GoTrueApi.js.map"]},"metadata":{},"sourceType":"module"}