{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants';\nimport { stripTrailingSlash, isBrowser } from './lib/helpers';\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient';\nimport { SupabaseQueryBuilder } from './lib/SupabaseQueryBuilder';\nimport { SupabaseStorageClient } from '@supabase/storage-js';\nimport { FunctionsClient } from '@supabase/functions-js';\nimport { PostgrestClient } from '@supabase/postgrest-js';\nimport { RealtimeClient } from '@supabase/realtime-js';\nvar DEFAULT_OPTIONS = {\n  schema: 'public',\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS\n};\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\n\nvar SupabaseClient = /*#__PURE__*/function () {\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.headers Any additional headers to send with each network request.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.fetch A custom fetch implementation.\n   */\n  function SupabaseClient(supabaseUrl, supabaseKey, options) {\n    _classCallCheck(this, SupabaseClient);\n\n    this.supabaseUrl = supabaseUrl;\n    this.supabaseKey = supabaseKey;\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.');\n    if (!supabaseKey) throw new Error('supabaseKey is required.');\n\n    var _supabaseUrl = stripTrailingSlash(supabaseUrl);\n\n    var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.restUrl = \"\".concat(_supabaseUrl, \"/rest/v1\");\n    this.realtimeUrl = \"\".concat(_supabaseUrl, \"/realtime/v1\").replace('http', 'ws');\n    this.authUrl = \"\".concat(_supabaseUrl, \"/auth/v1\");\n    this.storageUrl = \"\".concat(_supabaseUrl, \"/storage/v1\");\n\n    var isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/);\n\n    if (isPlatform) {\n      var urlParts = _supabaseUrl.split('.');\n\n      this.functionsUrl = \"\".concat(urlParts[0], \".functions.\").concat(urlParts[1], \".\").concat(urlParts[2]);\n    } else {\n      this.functionsUrl = \"\".concat(_supabaseUrl, \"/functions/v1\");\n    }\n\n    this.schema = settings.schema;\n    this.multiTab = settings.multiTab;\n    this.fetch = settings.fetch;\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), options === null || options === void 0 ? void 0 : options.headers);\n    this.shouldThrowOnError = settings.shouldThrowOnError || false;\n    this.auth = this._initSupabaseAuthClient(settings);\n    this.realtime = this._initRealtimeClient(Object.assign({\n      headers: this.headers\n    }, settings.realtime));\n\n    this._listenForAuthEvents();\n\n    this._listenForMultiTabEvents(); // In the future we might allow the user to pass in a logger to receive these events.\n    // this.realtime.onOpen(() => console.log('OPEN'))\n    // this.realtime.onClose(() => console.log('CLOSED'))\n    // this.realtime.onError((e: Error) => console.log('Socket error', e))\n\n  }\n  /**\n   * Supabase Functions allows you to deploy and invoke edge functions.\n   */\n\n\n  _createClass(SupabaseClient, [{\n    key: \"functions\",\n    get: function get() {\n      return new FunctionsClient(this.functionsUrl, {\n        headers: this._getAuthHeaders(),\n        customFetch: this.fetch\n      });\n    }\n    /**\n     * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n     */\n\n  }, {\n    key: \"storage\",\n    get: function get() {\n      return new SupabaseStorageClient(this.storageUrl, this._getAuthHeaders(), this.fetch);\n    }\n    /**\n     * Perform a table operation.\n     *\n     * @param table The table name to operate on.\n     */\n\n  }, {\n    key: \"from\",\n    value: function from(table) {\n      var url = \"\".concat(this.restUrl, \"/\").concat(table);\n      return new SupabaseQueryBuilder(url, {\n        headers: this._getAuthHeaders(),\n        schema: this.schema,\n        realtime: this.realtime,\n        table: table,\n        fetch: this.fetch,\n        shouldThrowOnError: this.shouldThrowOnError\n      });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn  The function name to call.\n     * @param params  The parameters to pass to the function call.\n     * @param head   When set to true, no data will be returned.\n     * @param count  Count algorithm to use to count rows in a table.\n     *\n     */\n\n  }, {\n    key: \"rpc\",\n    value: function rpc(fn, params) {\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          _ref$head = _ref.head,\n          head = _ref$head === void 0 ? false : _ref$head,\n          _ref$count = _ref.count,\n          count = _ref$count === void 0 ? null : _ref$count;\n\n      var rest = this._initPostgRESTClient();\n\n      return rest.rpc(fn, params, {\n        head: head,\n        count: count\n      });\n    }\n    /**\n     * Creates a channel with Broadcast and Presence.\n     * Activated when vsndate query param is present in the WebSocket URL.\n     */\n\n  }, {\n    key: \"channel\",\n    value: function channel(name, opts) {\n      var _a, _b;\n\n      var userToken = (_b = (_a = this.auth.session()) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;\n\n      if (!this.realtime.isConnected()) {\n        this.realtime.connect();\n      }\n\n      return this.realtime.channel(name, Object.assign(Object.assign({}, opts), {\n        user_token: userToken\n      }));\n    }\n    /**\n     * Closes and removes all subscriptions and returns a list of removed\n     * subscriptions and their errors.\n     */\n\n  }, {\n    key: \"removeAllSubscriptions\",\n    value: function removeAllSubscriptions() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this = this;\n\n        var allSubs, allSubPromises, allRemovedSubs;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                allSubs = this.getSubscriptions().slice();\n                allSubPromises = allSubs.map(function (sub) {\n                  return _this.removeSubscription(sub);\n                });\n                _context.next = 4;\n                return Promise.all(allSubPromises);\n\n              case 4:\n                allRemovedSubs = _context.sent;\n                return _context.abrupt(\"return\", allRemovedSubs.map(function (_ref2, i) {\n                  var error = _ref2.error;\n                  return {\n                    data: {\n                      subscription: allSubs[i]\n                    },\n                    error: error\n                  };\n                }));\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Closes and removes a channel and returns the number of open channels.\n     *\n     * @param channel The channel you want to close and remove.\n     */\n\n  }, {\n    key: \"removeChannel\",\n    value: function removeChannel(channel) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _yield$this$_closeSub, error, allChans, openChanCount;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._closeSubscription(channel);\n\n              case 2:\n                _yield$this$_closeSub = _context2.sent;\n                error = _yield$this$_closeSub.error;\n                allChans = this.getSubscriptions();\n                openChanCount = allChans.filter(function (chan) {\n                  return chan.isJoined();\n                }).length;\n\n                if (!(allChans.length === 0)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                _context2.next = 9;\n                return this.realtime.disconnect();\n\n              case 9:\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    openChannels: openChanCount\n                  },\n                  error: error\n                });\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Closes and removes a subscription and returns the number of open subscriptions.\n     *\n     * @param subscription The subscription you want to close and remove.\n     */\n\n  }, {\n    key: \"removeSubscription\",\n    value: function removeSubscription(subscription) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _yield$this$_closeSub2, error, allSubs, openSubCount;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._closeSubscription(subscription);\n\n              case 2:\n                _yield$this$_closeSub2 = _context3.sent;\n                error = _yield$this$_closeSub2.error;\n                allSubs = this.getSubscriptions();\n                openSubCount = allSubs.filter(function (chan) {\n                  return chan.isJoined();\n                }).length;\n\n                if (!(allSubs.length === 0)) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                _context3.next = 9;\n                return this.realtime.disconnect();\n\n              case 9:\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    openSubscriptions: openSubCount\n                  },\n                  error: error\n                });\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"_closeSubscription\",\n    value: function _closeSubscription(subscription) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var error, _yield$this$_unsubscr, unsubError;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                error = null;\n\n                if (subscription.isClosed()) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                _context4.next = 4;\n                return this._unsubscribeSubscription(subscription);\n\n              case 4:\n                _yield$this$_unsubscr = _context4.sent;\n                unsubError = _yield$this$_unsubscr.error;\n                error = unsubError;\n\n              case 7:\n                this.realtime.remove(subscription);\n                return _context4.abrupt(\"return\", {\n                  error: error\n                });\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"_unsubscribeSubscription\",\n    value: function _unsubscribeSubscription(subscription) {\n      return new Promise(function (resolve) {\n        subscription.unsubscribe().receive('ok', function () {\n          return resolve({\n            error: null\n          });\n        }).receive('error', function (error) {\n          return resolve({\n            error: error\n          });\n        }).receive('timeout', function () {\n          return resolve({\n            error: new Error('timed out')\n          });\n        });\n      });\n    }\n    /**\n     * Returns an array of all your subscriptions.\n     */\n\n  }, {\n    key: \"getSubscriptions\",\n    value: function getSubscriptions() {\n      return this.realtime.channels;\n    }\n  }, {\n    key: \"_initSupabaseAuthClient\",\n    value: function _initSupabaseAuthClient(_ref3) {\n      var autoRefreshToken = _ref3.autoRefreshToken,\n          persistSession = _ref3.persistSession,\n          detectSessionInUrl = _ref3.detectSessionInUrl,\n          localStorage = _ref3.localStorage,\n          headers = _ref3.headers,\n          fetch = _ref3.fetch,\n          cookieOptions = _ref3.cookieOptions,\n          multiTab = _ref3.multiTab;\n      var authHeaders = {\n        Authorization: \"Bearer \".concat(this.supabaseKey),\n        apikey: \"\".concat(this.supabaseKey)\n      };\n      return new SupabaseAuthClient({\n        url: this.authUrl,\n        headers: Object.assign(Object.assign({}, headers), authHeaders),\n        autoRefreshToken: autoRefreshToken,\n        persistSession: persistSession,\n        detectSessionInUrl: detectSessionInUrl,\n        localStorage: localStorage,\n        fetch: fetch,\n        cookieOptions: cookieOptions,\n        multiTab: multiTab\n      });\n    }\n  }, {\n    key: \"_initRealtimeClient\",\n    value: function _initRealtimeClient(options) {\n      return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), {\n        params: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.params), {\n          apikey: this.supabaseKey\n        })\n      }));\n    }\n  }, {\n    key: \"_initPostgRESTClient\",\n    value: function _initPostgRESTClient() {\n      return new PostgrestClient(this.restUrl, {\n        headers: this._getAuthHeaders(),\n        schema: this.schema,\n        fetch: this.fetch,\n        throwOnError: this.shouldThrowOnError\n      });\n    }\n  }, {\n    key: \"_getAuthHeaders\",\n    value: function _getAuthHeaders() {\n      var _a, _b;\n\n      var headers = Object.assign({}, this.headers);\n      var authBearer = (_b = (_a = this.auth.session()) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;\n      headers['apikey'] = this.supabaseKey;\n      headers['Authorization'] = headers['Authorization'] || \"Bearer \".concat(authBearer);\n      return headers;\n    }\n  }, {\n    key: \"_listenForMultiTabEvents\",\n    value: function _listenForMultiTabEvents() {\n      var _this2 = this;\n\n      if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n        return null;\n      }\n\n      try {\n        return window === null || window === void 0 ? void 0 : window.addEventListener('storage', function (e) {\n          var _a, _b, _c;\n\n          if (e.key === STORAGE_KEY) {\n            var newSession = JSON.parse(String(e.newValue));\n            var accessToken = (_b = (_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n            var previousAccessToken = (_c = _this2.auth.session()) === null || _c === void 0 ? void 0 : _c.access_token;\n\n            if (!accessToken) {\n              _this2._handleTokenChanged('SIGNED_OUT', accessToken, 'STORAGE');\n            } else if (!previousAccessToken && accessToken) {\n              _this2._handleTokenChanged('SIGNED_IN', accessToken, 'STORAGE');\n            } else if (previousAccessToken !== accessToken) {\n              _this2._handleTokenChanged('TOKEN_REFRESHED', accessToken, 'STORAGE');\n            }\n          }\n        });\n      } catch (error) {\n        console.error('_listenForMultiTabEvents', error);\n        return null;\n      }\n    }\n  }, {\n    key: \"_listenForAuthEvents\",\n    value: function _listenForAuthEvents() {\n      var _this3 = this;\n\n      var _this$auth$onAuthStat = this.auth.onAuthStateChange(function (event, session) {\n        _this3._handleTokenChanged(event, session === null || session === void 0 ? void 0 : session.access_token, 'CLIENT');\n      }),\n          data = _this$auth$onAuthStat.data;\n\n      return data;\n    }\n  }, {\n    key: \"_handleTokenChanged\",\n    value: function _handleTokenChanged(event, token, source) {\n      if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') && this.changedAccessToken !== token) {\n        // Token has changed\n        this.realtime.setAuth(token); // Ideally we should call this.auth.recoverSession() - need to make public\n        // to trigger a \"SIGNED_IN\" event on this client.\n\n        if (source == 'STORAGE') this.auth.setAuth(token);\n        this.changedAccessToken = token;\n      } else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\n        // Token is removed\n        this.realtime.setAuth(this.supabaseKey);\n        if (source == 'STORAGE') this.auth.signOut();\n      }\n    }\n  }]);\n\n  return SupabaseClient;\n}();\n\nexport { SupabaseClient as default };","map":{"version":3,"sources":["../../src/SupabaseClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants';\nimport { stripTrailingSlash, isBrowser } from './lib/helpers';\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient';\nimport { SupabaseQueryBuilder } from './lib/SupabaseQueryBuilder';\nimport { SupabaseStorageClient } from '@supabase/storage-js';\nimport { FunctionsClient } from '@supabase/functions-js';\nimport { PostgrestClient } from '@supabase/postgrest-js';\nimport { RealtimeClient, } from '@supabase/realtime-js';\nconst DEFAULT_OPTIONS = {\n    schema: 'public',\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    multiTab: true,\n    headers: DEFAULT_HEADERS,\n};\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nexport default class SupabaseClient {\n    /**\n     * Create a new client for use in the browser.\n     * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n     * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n     * @param options.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n     * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.headers Any additional headers to send with each network request.\n     * @param options.realtime Options passed along to realtime-js constructor.\n     * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n     * @param options.fetch A custom fetch implementation.\n     */\n    constructor(supabaseUrl, supabaseKey, options) {\n        this.supabaseUrl = supabaseUrl;\n        this.supabaseKey = supabaseKey;\n        if (!supabaseUrl)\n            throw new Error('supabaseUrl is required.');\n        if (!supabaseKey)\n            throw new Error('supabaseKey is required.');\n        const _supabaseUrl = stripTrailingSlash(supabaseUrl);\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.restUrl = `${_supabaseUrl}/rest/v1`;\n        this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace('http', 'ws');\n        this.authUrl = `${_supabaseUrl}/auth/v1`;\n        this.storageUrl = `${_supabaseUrl}/storage/v1`;\n        const isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/);\n        if (isPlatform) {\n            const urlParts = _supabaseUrl.split('.');\n            this.functionsUrl = `${urlParts[0]}.functions.${urlParts[1]}.${urlParts[2]}`;\n        }\n        else {\n            this.functionsUrl = `${_supabaseUrl}/functions/v1`;\n        }\n        this.schema = settings.schema;\n        this.multiTab = settings.multiTab;\n        this.fetch = settings.fetch;\n        this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), options === null || options === void 0 ? void 0 : options.headers);\n        this.shouldThrowOnError = settings.shouldThrowOnError || false;\n        this.auth = this._initSupabaseAuthClient(settings);\n        this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers }, settings.realtime));\n        this._listenForAuthEvents();\n        this._listenForMultiTabEvents();\n        // In the future we might allow the user to pass in a logger to receive these events.\n        // this.realtime.onOpen(() => console.log('OPEN'))\n        // this.realtime.onClose(() => console.log('CLOSED'))\n        // this.realtime.onError((e: Error) => console.log('Socket error', e))\n    }\n    /**\n     * Supabase Functions allows you to deploy and invoke edge functions.\n     */\n    get functions() {\n        return new FunctionsClient(this.functionsUrl, {\n            headers: this._getAuthHeaders(),\n            customFetch: this.fetch,\n        });\n    }\n    /**\n     * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n     */\n    get storage() {\n        return new SupabaseStorageClient(this.storageUrl, this._getAuthHeaders(), this.fetch);\n    }\n    /**\n     * Perform a table operation.\n     *\n     * @param table The table name to operate on.\n     */\n    from(table) {\n        const url = `${this.restUrl}/${table}`;\n        return new SupabaseQueryBuilder(url, {\n            headers: this._getAuthHeaders(),\n            schema: this.schema,\n            realtime: this.realtime,\n            table,\n            fetch: this.fetch,\n            shouldThrowOnError: this.shouldThrowOnError,\n        });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn  The function name to call.\n     * @param params  The parameters to pass to the function call.\n     * @param head   When set to true, no data will be returned.\n     * @param count  Count algorithm to use to count rows in a table.\n     *\n     */\n    rpc(fn, params, { head = false, count = null, } = {}) {\n        const rest = this._initPostgRESTClient();\n        return rest.rpc(fn, params, { head, count });\n    }\n    /**\n     * Creates a channel with Broadcast and Presence.\n     * Activated when vsndate query param is present in the WebSocket URL.\n     */\n    channel(name, opts) {\n        var _a, _b;\n        const userToken = (_b = (_a = this.auth.session()) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;\n        if (!this.realtime.isConnected()) {\n            this.realtime.connect();\n        }\n        return this.realtime.channel(name, Object.assign(Object.assign({}, opts), { user_token: userToken }));\n    }\n    /**\n     * Closes and removes all subscriptions and returns a list of removed\n     * subscriptions and their errors.\n     */\n    removeAllSubscriptions() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const allSubs = this.getSubscriptions().slice();\n            const allSubPromises = allSubs.map((sub) => this.removeSubscription(sub));\n            const allRemovedSubs = yield Promise.all(allSubPromises);\n            return allRemovedSubs.map(({ error }, i) => {\n                return {\n                    data: { subscription: allSubs[i] },\n                    error,\n                };\n            });\n        });\n    }\n    /**\n     * Closes and removes a channel and returns the number of open channels.\n     *\n     * @param channel The channel you want to close and remove.\n     */\n    removeChannel(channel) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { error } = yield this._closeSubscription(channel);\n            const allChans = this.getSubscriptions();\n            const openChanCount = allChans.filter((chan) => chan.isJoined()).length;\n            if (allChans.length === 0)\n                yield this.realtime.disconnect();\n            return { data: { openChannels: openChanCount }, error };\n        });\n    }\n    /**\n     * Closes and removes a subscription and returns the number of open subscriptions.\n     *\n     * @param subscription The subscription you want to close and remove.\n     */\n    removeSubscription(subscription) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { error } = yield this._closeSubscription(subscription);\n            const allSubs = this.getSubscriptions();\n            const openSubCount = allSubs.filter((chan) => chan.isJoined()).length;\n            if (allSubs.length === 0)\n                yield this.realtime.disconnect();\n            return { data: { openSubscriptions: openSubCount }, error };\n        });\n    }\n    _closeSubscription(subscription) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let error = null;\n            if (!subscription.isClosed()) {\n                const { error: unsubError } = yield this._unsubscribeSubscription(subscription);\n                error = unsubError;\n            }\n            this.realtime.remove(subscription);\n            return { error };\n        });\n    }\n    _unsubscribeSubscription(subscription) {\n        return new Promise((resolve) => {\n            subscription\n                .unsubscribe()\n                .receive('ok', () => resolve({ error: null }))\n                .receive('error', (error) => resolve({ error }))\n                .receive('timeout', () => resolve({ error: new Error('timed out') }));\n        });\n    }\n    /**\n     * Returns an array of all your subscriptions.\n     */\n    getSubscriptions() {\n        return this.realtime.channels;\n    }\n    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, localStorage, headers, fetch, cookieOptions, multiTab, }) {\n        const authHeaders = {\n            Authorization: `Bearer ${this.supabaseKey}`,\n            apikey: `${this.supabaseKey}`,\n        };\n        return new SupabaseAuthClient({\n            url: this.authUrl,\n            headers: Object.assign(Object.assign({}, headers), authHeaders),\n            autoRefreshToken,\n            persistSession,\n            detectSessionInUrl,\n            localStorage,\n            fetch,\n            cookieOptions,\n            multiTab,\n        });\n    }\n    _initRealtimeClient(options) {\n        return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), { params: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.params), { apikey: this.supabaseKey }) }));\n    }\n    _initPostgRESTClient() {\n        return new PostgrestClient(this.restUrl, {\n            headers: this._getAuthHeaders(),\n            schema: this.schema,\n            fetch: this.fetch,\n            throwOnError: this.shouldThrowOnError,\n        });\n    }\n    _getAuthHeaders() {\n        var _a, _b;\n        const headers = Object.assign({}, this.headers);\n        const authBearer = (_b = (_a = this.auth.session()) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;\n        headers['apikey'] = this.supabaseKey;\n        headers['Authorization'] = headers['Authorization'] || `Bearer ${authBearer}`;\n        return headers;\n    }\n    _listenForMultiTabEvents() {\n        if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            return null;\n        }\n        try {\n            return window === null || window === void 0 ? void 0 : window.addEventListener('storage', (e) => {\n                var _a, _b, _c;\n                if (e.key === STORAGE_KEY) {\n                    const newSession = JSON.parse(String(e.newValue));\n                    const accessToken = (_b = (_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n                    const previousAccessToken = (_c = this.auth.session()) === null || _c === void 0 ? void 0 : _c.access_token;\n                    if (!accessToken) {\n                        this._handleTokenChanged('SIGNED_OUT', accessToken, 'STORAGE');\n                    }\n                    else if (!previousAccessToken && accessToken) {\n                        this._handleTokenChanged('SIGNED_IN', accessToken, 'STORAGE');\n                    }\n                    else if (previousAccessToken !== accessToken) {\n                        this._handleTokenChanged('TOKEN_REFRESHED', accessToken, 'STORAGE');\n                    }\n                }\n            });\n        }\n        catch (error) {\n            console.error('_listenForMultiTabEvents', error);\n            return null;\n        }\n    }\n    _listenForAuthEvents() {\n        let { data } = this.auth.onAuthStateChange((event, session) => {\n            this._handleTokenChanged(event, session === null || session === void 0 ? void 0 : session.access_token, 'CLIENT');\n        });\n        return data;\n    }\n    _handleTokenChanged(event, token, source) {\n        if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n            this.changedAccessToken !== token) {\n            // Token has changed\n            this.realtime.setAuth(token);\n            // Ideally we should call this.auth.recoverSession() - need to make public\n            // to trigger a \"SIGNED_IN\" event on this client.\n            if (source == 'STORAGE')\n                this.auth.setAuth(token);\n            this.changedAccessToken = token;\n        }\n        else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\n            // Token is removed\n            this.realtime.setAuth(this.supabaseKey);\n            if (source == 'STORAGE')\n                this.auth.signOut();\n        }\n    }\n}\n//# sourceMappingURL=SupabaseClient.js.map"]},"metadata":{},"sourceType":"module"}