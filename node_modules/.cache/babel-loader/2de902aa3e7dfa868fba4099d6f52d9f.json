{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid, setItemAsync, removeItemAsync, getItemSynchronously, getItemAsync } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY, EXPIRY_MARGIN, NETWORK_FAILURE } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nvar DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS\n};\n\nvar GoTrueClient = /*#__PURE__*/function () {\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  function GoTrueClient(options) {\n    _classCallCheck(this, GoTrueClient);\n\n    this.stateChangeEmitters = new Map();\n    this.networkRetries = 0;\n    var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.currentUser = null;\n    this.currentSession = null;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.multiTab = settings.multiTab;\n    this.localStorage = settings.localStorage || globalThis.localStorage;\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch\n    });\n\n    this._recoverSession();\n\n    this._recoverAndRefresh();\n\n    this._listenForMultiTabEvents();\n\n    this._handleVisibilityChange();\n\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({\n        storeSession: true\n      }).then(function (_ref) {\n        var error = _ref.error;\n\n        if (error) {\n          console.error('Error getting session from URL.', error);\n        }\n      });\n    }\n  }\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n   * @param data Optional user metadata.\n   */\n\n\n  _createClass(GoTrueClient, [{\n    key: \"signUp\",\n    value: function signUp(_ref2) {\n      var email = _ref2.email,\n          password = _ref2.password,\n          phone = _ref2.phone;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _ref3, data, error, session, user;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n\n                this._removeSession();\n\n                if (!(phone && password)) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 5;\n                return this.api.signUpWithPhone(phone, password, {\n                  data: options.data,\n                  captchaToken: options.captchaToken\n                });\n\n              case 5:\n                _context.t0 = _context.sent;\n                _context.next = 11;\n                break;\n\n              case 8:\n                _context.next = 10;\n                return this.api.signUpWithEmail(email, password, {\n                  redirectTo: options.redirectTo,\n                  data: options.data,\n                  captchaToken: options.captchaToken\n                });\n\n              case 10:\n                _context.t0 = _context.sent;\n\n              case 11:\n                _ref3 = _context.t0;\n                data = _ref3.data;\n                error = _ref3.error;\n\n                if (!error) {\n                  _context.next = 16;\n                  break;\n                }\n\n                throw error;\n\n              case 16:\n                if (data) {\n                  _context.next = 18;\n                  break;\n                }\n\n                throw 'An error occurred on sign up.';\n\n              case 18:\n                session = null;\n                user = null;\n\n                if (data.access_token) {\n                  session = data;\n                  user = session.user;\n\n                  this._saveSession(session);\n\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n\n                if (data.id) {\n                  user = data;\n                }\n\n                return _context.abrupt(\"return\", {\n                  user: user,\n                  session: session,\n                  error: null\n                });\n\n              case 25:\n                _context.prev = 25;\n                _context.t1 = _context[\"catch\"](0);\n                return _context.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _context.t1\n                });\n\n              case 28:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 25]]);\n      }));\n    }\n    /**\n     * Log in an existing user, or login via a third-party provider.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param password The user's password.\n     * @param refreshToken A valid refresh token that was returned on login.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n\n  }, {\n    key: \"signIn\",\n    value: function signIn(_ref4) {\n      var email = _ref4.email,\n          phone = _ref4.phone,\n          password = _ref4.password,\n          refreshToken = _ref4.refreshToken,\n          provider = _ref4.provider,\n          oidc = _ref4.oidc;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _yield$this$api$sendM, error, _yield$this$api$sendM2, _error, _yield$this$_callRefr, _error2;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n\n                this._removeSession();\n\n                if (!(email && !password)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 5;\n                return this.api.sendMagicLinkEmail(email, {\n                  redirectTo: options.redirectTo,\n                  shouldCreateUser: options.shouldCreateUser,\n                  captchaToken: options.captchaToken\n                });\n\n              case 5:\n                _yield$this$api$sendM = _context2.sent;\n                error = _yield$this$api$sendM.error;\n                return _context2.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: error\n                });\n\n              case 8:\n                if (!(email && password)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this._handleEmailSignIn(email, password, {\n                  redirectTo: options.redirectTo\n                }));\n\n              case 10:\n                if (!(phone && !password)) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                _context2.next = 13;\n                return this.api.sendMobileOTP(phone, {\n                  shouldCreateUser: options.shouldCreateUser,\n                  captchaToken: options.captchaToken\n                });\n\n              case 13:\n                _yield$this$api$sendM2 = _context2.sent;\n                _error = _yield$this$api$sendM2.error;\n                return _context2.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _error\n                });\n\n              case 16:\n                if (!(phone && password)) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this._handlePhoneSignIn(phone, password));\n\n              case 18:\n                if (!refreshToken) {\n                  _context2.next = 26;\n                  break;\n                }\n\n                _context2.next = 21;\n                return this._callRefreshToken(refreshToken);\n\n              case 21:\n                _yield$this$_callRefr = _context2.sent;\n                _error2 = _yield$this$_callRefr.error;\n\n                if (!_error2) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                throw _error2;\n\n              case 25:\n                return _context2.abrupt(\"return\", {\n                  user: this.currentUser,\n                  session: this.currentSession,\n                  error: null\n                });\n\n              case 26:\n                if (!provider) {\n                  _context2.next = 28;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this._handleProviderSignIn(provider, {\n                  redirectTo: options.redirectTo,\n                  scopes: options.scopes\n                }));\n\n              case 28:\n                if (!oidc) {\n                  _context2.next = 30;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this._handleOpenIDConnectSignIn(oidc));\n\n              case 30:\n                throw new Error(\"You must provide either an email, phone number, a third-party provider or OpenID Connect.\");\n\n              case 33:\n                _context2.prev = 33;\n                _context2.t0 = _context2[\"catch\"](0);\n                return _context2.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _context2.t0\n                });\n\n              case 36:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 33]]);\n      }));\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param token The user's password.\n     * @param type The user's verification type.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n\n  }, {\n    key: \"verifyOTP\",\n    value: function verifyOTP(params) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _yield$this$api$verif, data, error, session, user;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n\n                this._removeSession();\n\n                _context3.next = 4;\n                return this.api.verifyOTP(params, options);\n\n              case 4:\n                _yield$this$api$verif = _context3.sent;\n                data = _yield$this$api$verif.data;\n                error = _yield$this$api$verif.error;\n\n                if (!error) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                throw error;\n\n              case 9:\n                if (data) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                throw 'An error occurred on token verification.';\n\n              case 11:\n                session = null;\n                user = null;\n\n                if (data.access_token) {\n                  session = data;\n                  user = session.user;\n\n                  this._saveSession(session);\n\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n\n                if (data.id) {\n                  user = data;\n                }\n\n                return _context3.abrupt(\"return\", {\n                  user: user,\n                  session: session,\n                  error: null\n                });\n\n              case 18:\n                _context3.prev = 18;\n                _context3.t0 = _context3[\"catch\"](0);\n                return _context3.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _context3.t0\n                });\n\n              case 21:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 18]]);\n      }));\n    }\n    /**\n     * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n     *\n     * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n     */\n\n  }, {\n    key: \"user\",\n    value: function user() {\n      return this.currentUser;\n    }\n    /**\n     * Returns the session data, if there is an active session.\n     */\n\n  }, {\n    key: \"session\",\n    value: function session() {\n      return this.currentSession;\n    }\n    /**\n     * Force refreshes the session including the user data in case it was updated in a different session.\n     */\n\n  }, {\n    key: \"refreshSession\",\n    value: function refreshSession() {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _yield$this$_callRefr2, error;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n\n                if ((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new Error('Not logged in.');\n\n              case 3:\n                _context4.next = 5;\n                return this._callRefreshToken();\n\n              case 5:\n                _yield$this$_callRefr2 = _context4.sent;\n                error = _yield$this$_callRefr2.error;\n\n                if (!error) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                throw error;\n\n              case 9:\n                return _context4.abrupt(\"return\", {\n                  data: this.currentSession,\n                  user: this.currentUser,\n                  error: null\n                });\n\n              case 12:\n                _context4.prev = 12;\n                _context4.t0 = _context4[\"catch\"](0);\n                return _context4.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  error: _context4.t0\n                });\n\n              case 15:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 12]]);\n      }));\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(attributes) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _yield$this$api$updat, user, error, session;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n\n                if ((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                throw new Error('Not logged in.');\n\n              case 3:\n                _context5.next = 5;\n                return this.api.updateUser(this.currentSession.access_token, attributes);\n\n              case 5:\n                _yield$this$api$updat = _context5.sent;\n                user = _yield$this$api$updat.user;\n                error = _yield$this$api$updat.error;\n\n                if (!error) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                throw error;\n\n              case 10:\n                if (user) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                throw Error('Invalid user data.');\n\n              case 12:\n                session = Object.assign(Object.assign({}, this.currentSession), {\n                  user: user\n                });\n\n                this._saveSession(session);\n\n                this._notifyAllSubscribers('USER_UPDATED');\n\n                return _context5.abrupt(\"return\", {\n                  data: user,\n                  user: user,\n                  error: null\n                });\n\n              case 18:\n                _context5.prev = 18;\n                _context5.t0 = _context5[\"catch\"](0);\n                return _context5.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  error: _context5.t0\n                });\n\n              case 21:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 18]]);\n      }));\n    }\n    /**\n     * Sets the session data from refresh_token and returns current Session and Error\n     * @param refresh_token a JWT token\n     */\n\n  }, {\n    key: \"setSession\",\n    value: function setSession(refresh_token) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _yield$this$api$refre, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n\n                if (refresh_token) {\n                  _context6.next = 3;\n                  break;\n                }\n\n                throw new Error('No current session.');\n\n              case 3:\n                _context6.next = 5;\n                return this.api.refreshAccessToken(refresh_token);\n\n              case 5:\n                _yield$this$api$refre = _context6.sent;\n                data = _yield$this$api$refre.data;\n                error = _yield$this$api$refre.error;\n\n                if (!error) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", {\n                  session: null,\n                  error: error\n                });\n\n              case 10:\n                this._saveSession(data);\n\n                this._notifyAllSubscribers('SIGNED_IN');\n\n                return _context6.abrupt(\"return\", {\n                  session: data,\n                  error: null\n                });\n\n              case 15:\n                _context6.prev = 15;\n                _context6.t0 = _context6[\"catch\"](0);\n                return _context6.abrupt(\"return\", {\n                  error: _context6.t0,\n                  session: null\n                });\n\n              case 18:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[0, 15]]);\n      }));\n    }\n    /**\n     * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n     * @param access_token a jwt access token\n     */\n\n  }, {\n    key: \"setAuth\",\n    value: function setAuth(access_token) {\n      this.currentSession = Object.assign(Object.assign({}, this.currentSession), {\n        access_token: access_token,\n        token_type: 'bearer',\n        user: this.user()\n      });\n\n      this._notifyAllSubscribers('TOKEN_REFRESHED');\n\n      return this.currentSession;\n    }\n    /**\n     * Gets the session data from a URL string\n     * @param options.storeSession Optionally store the session in the browser\n     */\n\n  }, {\n    key: \"getSessionFromUrl\",\n    value: function getSessionFromUrl(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var error_description, provider_token, access_token, expires_in, refresh_token, token_type, timeNow, expires_at, _yield$this$api$getUs, user, error, session, recoveryMode;\n\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n\n                if (isBrowser()) {\n                  _context7.next = 3;\n                  break;\n                }\n\n                throw new Error('No browser detected.');\n\n              case 3:\n                error_description = getParameterByName('error_description');\n\n                if (!error_description) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                throw new Error(error_description);\n\n              case 6:\n                provider_token = getParameterByName('provider_token');\n                access_token = getParameterByName('access_token');\n\n                if (access_token) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                throw new Error('No access_token detected.');\n\n              case 10:\n                expires_in = getParameterByName('expires_in');\n\n                if (expires_in) {\n                  _context7.next = 13;\n                  break;\n                }\n\n                throw new Error('No expires_in detected.');\n\n              case 13:\n                refresh_token = getParameterByName('refresh_token');\n\n                if (refresh_token) {\n                  _context7.next = 16;\n                  break;\n                }\n\n                throw new Error('No refresh_token detected.');\n\n              case 16:\n                token_type = getParameterByName('token_type');\n\n                if (token_type) {\n                  _context7.next = 19;\n                  break;\n                }\n\n                throw new Error('No token_type detected.');\n\n              case 19:\n                timeNow = Math.round(Date.now() / 1000);\n                expires_at = timeNow + parseInt(expires_in);\n                _context7.next = 23;\n                return this.api.getUser(access_token);\n\n              case 23:\n                _yield$this$api$getUs = _context7.sent;\n                user = _yield$this$api$getUs.user;\n                error = _yield$this$api$getUs.error;\n\n                if (!error) {\n                  _context7.next = 28;\n                  break;\n                }\n\n                throw error;\n\n              case 28:\n                session = {\n                  provider_token: provider_token,\n                  access_token: access_token,\n                  expires_in: parseInt(expires_in),\n                  expires_at: expires_at,\n                  refresh_token: refresh_token,\n                  token_type: token_type,\n                  user: user\n                };\n\n                if (options === null || options === void 0 ? void 0 : options.storeSession) {\n                  this._saveSession(session);\n\n                  recoveryMode = getParameterByName('type');\n\n                  this._notifyAllSubscribers('SIGNED_IN');\n\n                  if (recoveryMode === 'recovery') {\n                    this._notifyAllSubscribers('PASSWORD_RECOVERY');\n                  }\n                } // Remove tokens from URL\n\n\n                window.location.hash = '';\n                return _context7.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 34:\n                _context7.prev = 34;\n                _context7.t0 = _context7[\"catch\"](0);\n                return _context7.abrupt(\"return\", {\n                  data: null,\n                  error: _context7.t0\n                });\n\n              case 37:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 34]]);\n      }));\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n     *\n     * For server-side management, you can disable sessions by passing a JWT through to `auth.api.signOut(JWT: string)`\n     */\n\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var accessToken, _yield$this$api$signO, error;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n\n                this._removeSession();\n\n                this._notifyAllSubscribers('SIGNED_OUT');\n\n                if (!accessToken) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                _context8.next = 6;\n                return this.api.signOut(accessToken);\n\n              case 6:\n                _yield$this$api$signO = _context8.sent;\n                error = _yield$this$api$signO.error;\n\n                if (!error) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", {\n                  error: error\n                });\n\n              case 10:\n                return _context8.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 11:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n     */\n\n  }, {\n    key: \"onAuthStateChange\",\n    value: function onAuthStateChange(callback) {\n      var _this = this;\n\n      try {\n        var id = uuid();\n        var subscription = {\n          id: id,\n          callback: callback,\n          unsubscribe: function unsubscribe() {\n            _this.stateChangeEmitters.delete(id);\n          }\n        };\n        this.stateChangeEmitters.set(id, subscription);\n        return {\n          data: subscription,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    }\n  }, {\n    key: \"_handleEmailSignIn\",\n    value: function _handleEmailSignIn(email, password) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var _yield$this$api$signI, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                _context9.next = 3;\n                return this.api.signInWithEmail(email, password, {\n                  redirectTo: options.redirectTo\n                });\n\n              case 3:\n                _yield$this$api$signI = _context9.sent;\n                data = _yield$this$api$signI.data;\n                error = _yield$this$api$signI.error;\n\n                if (!(error || !data)) {\n                  _context9.next = 8;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  session: null,\n                  error: error\n                });\n\n              case 8:\n                if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n                  this._saveSession(data);\n\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n\n                return _context9.abrupt(\"return\", {\n                  data: data,\n                  user: data.user,\n                  session: data,\n                  error: null\n                });\n\n              case 12:\n                _context9.prev = 12;\n                _context9.t0 = _context9[\"catch\"](0);\n                return _context9.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  session: null,\n                  error: _context9.t0\n                });\n\n              case 15:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 12]]);\n      }));\n    }\n  }, {\n    key: \"_handlePhoneSignIn\",\n    value: function _handlePhoneSignIn(phone, password) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _yield$this$api$signI2, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.prev = 0;\n                _context10.next = 3;\n                return this.api.signInWithPhone(phone, password);\n\n              case 3:\n                _yield$this$api$signI2 = _context10.sent;\n                data = _yield$this$api$signI2.data;\n                error = _yield$this$api$signI2.error;\n\n                if (!(error || !data)) {\n                  _context10.next = 8;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  session: null,\n                  error: error\n                });\n\n              case 8:\n                if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n                  this._saveSession(data);\n\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: data,\n                  user: data.user,\n                  session: data,\n                  error: null\n                });\n\n              case 12:\n                _context10.prev = 12;\n                _context10.t0 = _context10[\"catch\"](0);\n                return _context10.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  session: null,\n                  error: _context10.t0\n                });\n\n              case 15:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[0, 12]]);\n      }));\n    }\n  }, {\n    key: \"_handleProviderSignIn\",\n    value: function _handleProviderSignIn(provider) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var url = this.api.getUrlForProvider(provider, {\n        redirectTo: options.redirectTo,\n        scopes: options.scopes\n      });\n\n      try {\n        // try to open on the browser\n        if (isBrowser()) {\n          window.location.href = url;\n        }\n\n        return {\n          provider: provider,\n          url: url,\n          data: null,\n          session: null,\n          user: null,\n          error: null\n        };\n      } catch (e) {\n        // fallback to returning the URL\n        if (url) return {\n          provider: provider,\n          url: url,\n          data: null,\n          session: null,\n          user: null,\n          error: null\n        };\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    }\n  }, {\n    key: \"_handleOpenIDConnectSignIn\",\n    value: function _handleOpenIDConnectSignIn(_ref5) {\n      var id_token = _ref5.id_token,\n          nonce = _ref5.nonce,\n          client_id = _ref5.client_id,\n          issuer = _ref5.issuer,\n          provider = _ref5.provider;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var _yield$this$api$signI3, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!(id_token && nonce && (client_id && issuer || provider))) {\n                  _context11.next = 17;\n                  break;\n                }\n\n                _context11.prev = 1;\n                _context11.next = 4;\n                return this.api.signInWithOpenIDConnect({\n                  id_token: id_token,\n                  nonce: nonce,\n                  client_id: client_id,\n                  issuer: issuer,\n                  provider: provider\n                });\n\n              case 4:\n                _yield$this$api$signI3 = _context11.sent;\n                data = _yield$this$api$signI3.data;\n                error = _yield$this$api$signI3.error;\n\n                if (!(error || !data)) {\n                  _context11.next = 9;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: error\n                });\n\n              case 9:\n                this._saveSession(data);\n\n                this._notifyAllSubscribers('SIGNED_IN');\n\n                return _context11.abrupt(\"return\", {\n                  user: data.user,\n                  session: data,\n                  error: null\n                });\n\n              case 14:\n                _context11.prev = 14;\n                _context11.t0 = _context11[\"catch\"](1);\n                return _context11.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _context11.t0\n                });\n\n              case 17:\n                throw new Error(\"You must provide a OpenID Connect provider with your id token and nonce.\");\n\n              case 18:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[1, 14]]);\n      }));\n    }\n    /**\n     * Attempts to get the session from LocalStorage\n     * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n     */\n\n  }, {\n    key: \"_recoverSession\",\n    value: function _recoverSession() {\n      try {\n        var data = getItemSynchronously(this.localStorage, STORAGE_KEY);\n        if (!data) return null;\n        var currentSession = data.currentSession,\n            expiresAt = data.expiresAt;\n        var timeNow = Math.round(Date.now() / 1000);\n\n        if (expiresAt >= timeNow + EXPIRY_MARGIN && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n          this._saveSession(currentSession);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n      } catch (error) {\n        console.log('error', error);\n      }\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n\n  }, {\n    key: \"_recoverAndRefresh\",\n    value: function _recoverAndRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var _this2 = this;\n\n        var data, currentSession, expiresAt, timeNow, _yield$this$_callRefr3, error;\n\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n                _context12.next = 3;\n                return getItemAsync(this.localStorage, STORAGE_KEY);\n\n              case 3:\n                data = _context12.sent;\n\n                if (data) {\n                  _context12.next = 6;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", null);\n\n              case 6:\n                currentSession = data.currentSession, expiresAt = data.expiresAt;\n                timeNow = Math.round(Date.now() / 1000);\n\n                if (!(expiresAt < timeNow + EXPIRY_MARGIN)) {\n                  _context12.next = 29;\n                  break;\n                }\n\n                if (!(this.autoRefreshToken && currentSession.refresh_token)) {\n                  _context12.next = 26;\n                  break;\n                }\n\n                this.networkRetries++;\n                _context12.next = 13;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 13:\n                _yield$this$_callRefr3 = _context12.sent;\n                error = _yield$this$_callRefr3.error;\n\n                if (!error) {\n                  _context12.next = 23;\n                  break;\n                }\n\n                console.log(error.message);\n\n                if (!(error.message === NETWORK_FAILURE.ERROR_MESSAGE && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES)) {\n                  _context12.next = 21;\n                  break;\n                }\n\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                this.refreshTokenTimer = setTimeout(function () {\n                  return _this2._recoverAndRefresh();\n                }, Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                );\n                return _context12.abrupt(\"return\");\n\n              case 21:\n                _context12.next = 23;\n                return this._removeSession();\n\n              case 23:\n                this.networkRetries = 0;\n                _context12.next = 27;\n                break;\n\n              case 26:\n                this._removeSession();\n\n              case 27:\n                _context12.next = 30;\n                break;\n\n              case 29:\n                if (!currentSession) {\n                  console.log('Current session is missing data.');\n\n                  this._removeSession();\n                } else {\n                  // should be handled on _recoverSession method already\n                  // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n                  this._saveSession(currentSession);\n\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n\n              case 30:\n                _context12.next = 36;\n                break;\n\n              case 32:\n                _context12.prev = 32;\n                _context12.t0 = _context12[\"catch\"](0);\n                console.error(_context12.t0);\n                return _context12.abrupt(\"return\", null);\n\n              case 36:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[0, 32]]);\n      }));\n    }\n  }, {\n    key: \"_callRefreshToken\",\n    value: function _callRefreshToken(refresh_token) {\n      var _a;\n\n      if (refresh_token === void 0) {\n        refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token;\n      }\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var _yield$this$api$refre2, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.prev = 0;\n\n                if (refresh_token) {\n                  _context13.next = 3;\n                  break;\n                }\n\n                throw new Error('No current session.');\n\n              case 3:\n                _context13.next = 5;\n                return this.api.refreshAccessToken(refresh_token);\n\n              case 5:\n                _yield$this$api$refre2 = _context13.sent;\n                data = _yield$this$api$refre2.data;\n                error = _yield$this$api$refre2.error;\n\n                if (!error) {\n                  _context13.next = 10;\n                  break;\n                }\n\n                throw error;\n\n              case 10:\n                if (data) {\n                  _context13.next = 12;\n                  break;\n                }\n\n                throw Error('Invalid session data.');\n\n              case 12:\n                this._saveSession(data);\n\n                this._notifyAllSubscribers('TOKEN_REFRESHED');\n\n                this._notifyAllSubscribers('SIGNED_IN');\n\n                return _context13.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 18:\n                _context13.prev = 18;\n                _context13.t0 = _context13[\"catch\"](0);\n                return _context13.abrupt(\"return\", {\n                  data: null,\n                  error: _context13.t0\n                });\n\n              case 21:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[0, 18]]);\n      }));\n    }\n  }, {\n    key: \"_notifyAllSubscribers\",\n    value: function _notifyAllSubscribers(event) {\n      var _this3 = this;\n\n      this.stateChangeEmitters.forEach(function (x) {\n        return x.callback(event, _this3.currentSession);\n      });\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n\n  }, {\n    key: \"_saveSession\",\n    value: function _saveSession(session) {\n      this.currentSession = session;\n      this.currentUser = session.user;\n      var expiresAt = session.expires_at;\n\n      if (expiresAt) {\n        var timeNow = Math.round(Date.now() / 1000);\n        var expiresIn = expiresAt - timeNow;\n        var refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n\n        this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n      } // Do we need any extra check before persist session\n      // access_token or user ?\n\n\n      if (this.persistSession && session.expires_at) {\n        this._persistSession(this.currentSession);\n      }\n    }\n  }, {\n    key: \"_persistSession\",\n    value: function _persistSession(currentSession) {\n      var data = {\n        currentSession: currentSession,\n        expiresAt: currentSession.expires_at\n      };\n      setItemAsync(this.localStorage, STORAGE_KEY, data);\n    }\n  }, {\n    key: \"_removeSession\",\n    value: function _removeSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this.currentSession = null;\n                this.currentUser = null;\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                removeItemAsync(this.localStorage, STORAGE_KEY);\n\n              case 4:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n    }\n    /**\n     * Clear and re-create refresh token timer\n     * @param value time intervals in milliseconds\n     */\n\n  }, {\n    key: \"_startAutoRefreshToken\",\n    value: function _startAutoRefreshToken(value) {\n      var _this4 = this;\n\n      if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n      if (value <= 0 || !this.autoRefreshToken) return;\n      this.refreshTokenTimer = setTimeout(function () {\n        return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n          var _yield$this$_callRefr4, error;\n\n          return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n            while (1) {\n              switch (_context15.prev = _context15.next) {\n                case 0:\n                  this.networkRetries++;\n                  _context15.next = 3;\n                  return this._callRefreshToken();\n\n                case 3:\n                  _yield$this$_callRefr4 = _context15.sent;\n                  error = _yield$this$_callRefr4.error;\n                  if (!error) this.networkRetries = 0;\n                  if ((error === null || error === void 0 ? void 0 : error.message) === NETWORK_FAILURE.ERROR_MESSAGE && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n\n                case 7:\n                case \"end\":\n                  return _context15.stop();\n              }\n            }\n          }, _callee15, this);\n        }));\n      }, value);\n      if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n    }\n    /**\n     * Listens for changes to LocalStorage and updates the current session.\n     */\n\n  }, {\n    key: \"_listenForMultiTabEvents\",\n    value: function _listenForMultiTabEvents() {\n      var _this5 = this;\n\n      if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n        return false;\n      }\n\n      try {\n        window === null || window === void 0 ? void 0 : window.addEventListener('storage', function (e) {\n          var _a;\n\n          if (e.key === STORAGE_KEY) {\n            var newSession = JSON.parse(String(e.newValue));\n\n            if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n              _this5._saveSession(newSession.currentSession);\n\n              _this5._notifyAllSubscribers('SIGNED_IN');\n            } else {\n              _this5._removeSession();\n\n              _this5._notifyAllSubscribers('SIGNED_OUT');\n            }\n          }\n        });\n      } catch (error) {\n        console.error('_listenForMultiTabEvents', error);\n      }\n    }\n  }, {\n    key: \"_handleVisibilityChange\",\n    value: function _handleVisibilityChange() {\n      var _this6 = this;\n\n      if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n        return false;\n      }\n\n      try {\n        window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', function () {\n          if (document.visibilityState === 'visible') {\n            _this6._recoverAndRefresh();\n          }\n        });\n      } catch (error) {\n        console.error('_handleVisibilityChange', error);\n      }\n    }\n  }]);\n\n  return GoTrueClient;\n}();\n\nexport { GoTrueClient as default };","map":{"version":3,"sources":["../../src/GoTrueClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid, setItemAsync, removeItemAsync, getItemSynchronously, getItemAsync, } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY, EXPIRY_MARGIN, NETWORK_FAILURE, } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: GOTRUE_URL,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    multiTab: true,\n    headers: DEFAULT_HEADERS,\n};\nexport default class GoTrueClient {\n    /**\n     * Create a new client for use in the browser.\n     * @param options.url The URL of the GoTrue server.\n     * @param options.headers Any additional headers to send to the GoTrue server.\n     * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n     * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n     * @param options.cookieOptions\n     * @param options.fetch A custom fetch implementation.\n     */\n    constructor(options) {\n        this.stateChangeEmitters = new Map();\n        this.networkRetries = 0;\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.currentUser = null;\n        this.currentSession = null;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.persistSession = settings.persistSession;\n        this.multiTab = settings.multiTab;\n        this.localStorage = settings.localStorage || globalThis.localStorage;\n        this.api = new GoTrueApi({\n            url: settings.url,\n            headers: settings.headers,\n            cookieOptions: settings.cookieOptions,\n            fetch: settings.fetch,\n        });\n        this._recoverSession();\n        this._recoverAndRefresh();\n        this._listenForMultiTabEvents();\n        this._handleVisibilityChange();\n        if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n            // Handle the OAuth redirect\n            this.getSessionFromUrl({ storeSession: true }).then(({ error }) => {\n                if (error) {\n                    console.error('Error getting session from URL.', error);\n                }\n            });\n        }\n    }\n    /**\n     * Creates a new user.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param password The user's password.\n     * @param phone The user's phone number.\n     * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n     * @param data Optional user metadata.\n     */\n    signUp({ email, password, phone }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                const { data, error } = phone && password\n                    ? yield this.api.signUpWithPhone(phone, password, {\n                        data: options.data,\n                        captchaToken: options.captchaToken,\n                    })\n                    : yield this.api.signUpWithEmail(email, password, {\n                        redirectTo: options.redirectTo,\n                        data: options.data,\n                        captchaToken: options.captchaToken,\n                    });\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on sign up.';\n                }\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                    user = data;\n                }\n                return { user, session, error: null };\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Log in an existing user, or login via a third-party provider.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param password The user's password.\n     * @param refreshToken A valid refresh token that was returned on login.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n    signIn({ email, phone, password, refreshToken, provider, oidc }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                if (email && !password) {\n                    const { error } = yield this.api.sendMagicLinkEmail(email, {\n                        redirectTo: options.redirectTo,\n                        shouldCreateUser: options.shouldCreateUser,\n                        captchaToken: options.captchaToken,\n                    });\n                    return { user: null, session: null, error };\n                }\n                if (email && password) {\n                    return this._handleEmailSignIn(email, password, {\n                        redirectTo: options.redirectTo,\n                    });\n                }\n                if (phone && !password) {\n                    const { error } = yield this.api.sendMobileOTP(phone, {\n                        shouldCreateUser: options.shouldCreateUser,\n                        captchaToken: options.captchaToken,\n                    });\n                    return { user: null, session: null, error };\n                }\n                if (phone && password) {\n                    return this._handlePhoneSignIn(phone, password);\n                }\n                if (refreshToken) {\n                    // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n                    const { error } = yield this._callRefreshToken(refreshToken);\n                    if (error)\n                        throw error;\n                    return {\n                        user: this.currentUser,\n                        session: this.currentSession,\n                        error: null,\n                    };\n                }\n                if (provider) {\n                    return this._handleProviderSignIn(provider, {\n                        redirectTo: options.redirectTo,\n                        scopes: options.scopes,\n                    });\n                }\n                if (oidc) {\n                    return this._handleOpenIDConnectSignIn(oidc);\n                }\n                throw new Error(`You must provide either an email, phone number, a third-party provider or OpenID Connect.`);\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param token The user's password.\n     * @param type The user's verification type.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    verifyOTP(params, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                const { data, error } = yield this.api.verifyOTP(params, options);\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on token verification.';\n                }\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                    user = data;\n                }\n                return { user, session, error: null };\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n     *\n     * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n     */\n    user() {\n        return this.currentUser;\n    }\n    /**\n     * Returns the session data, if there is an active session.\n     */\n    session() {\n        return this.currentSession;\n    }\n    /**\n     * Force refreshes the session including the user data in case it was updated in a different session.\n     */\n    refreshSession() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))\n                    throw new Error('Not logged in.');\n                // currentSession and currentUser will be updated to latest on _callRefreshToken\n                const { error } = yield this._callRefreshToken();\n                if (error)\n                    throw error;\n                return { data: this.currentSession, user: this.currentUser, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, error: e };\n            }\n        });\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */\n    update(attributes) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))\n                    throw new Error('Not logged in.');\n                const { user, error } = yield this.api.updateUser(this.currentSession.access_token, attributes);\n                if (error)\n                    throw error;\n                if (!user)\n                    throw Error('Invalid user data.');\n                const session = Object.assign(Object.assign({}, this.currentSession), { user });\n                this._saveSession(session);\n                this._notifyAllSubscribers('USER_UPDATED');\n                return { data: user, user, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sets the session data from refresh_token and returns current Session and Error\n     * @param refresh_token a JWT token\n     */\n    setSession(refresh_token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!refresh_token) {\n                    throw new Error('No current session.');\n                }\n                const { data, error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error) {\n                    return { session: null, error: error };\n                }\n                this._saveSession(data);\n                this._notifyAllSubscribers('SIGNED_IN');\n                return { session: data, error: null };\n            }\n            catch (e) {\n                return { error: e, session: null };\n            }\n        });\n    }\n    /**\n     * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n     * @param access_token a jwt access token\n     */\n    setAuth(access_token) {\n        this.currentSession = Object.assign(Object.assign({}, this.currentSession), { access_token, token_type: 'bearer', user: this.user() });\n        this._notifyAllSubscribers('TOKEN_REFRESHED');\n        return this.currentSession;\n    }\n    /**\n     * Gets the session data from a URL string\n     * @param options.storeSession Optionally store the session in the browser\n     */\n    getSessionFromUrl(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!isBrowser())\n                    throw new Error('No browser detected.');\n                const error_description = getParameterByName('error_description');\n                if (error_description)\n                    throw new Error(error_description);\n                const provider_token = getParameterByName('provider_token');\n                const access_token = getParameterByName('access_token');\n                if (!access_token)\n                    throw new Error('No access_token detected.');\n                const expires_in = getParameterByName('expires_in');\n                if (!expires_in)\n                    throw new Error('No expires_in detected.');\n                const refresh_token = getParameterByName('refresh_token');\n                if (!refresh_token)\n                    throw new Error('No refresh_token detected.');\n                const token_type = getParameterByName('token_type');\n                if (!token_type)\n                    throw new Error('No token_type detected.');\n                const timeNow = Math.round(Date.now() / 1000);\n                const expires_at = timeNow + parseInt(expires_in);\n                const { user, error } = yield this.api.getUser(access_token);\n                if (error)\n                    throw error;\n                const session = {\n                    provider_token,\n                    access_token,\n                    expires_in: parseInt(expires_in),\n                    expires_at,\n                    refresh_token,\n                    token_type,\n                    user: user,\n                };\n                if (options === null || options === void 0 ? void 0 : options.storeSession) {\n                    this._saveSession(session);\n                    const recoveryMode = getParameterByName('type');\n                    this._notifyAllSubscribers('SIGNED_IN');\n                    if (recoveryMode === 'recovery') {\n                        this._notifyAllSubscribers('PASSWORD_RECOVERY');\n                    }\n                }\n                // Remove tokens from URL\n                window.location.hash = '';\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n     *\n     * For server-side management, you can disable sessions by passing a JWT through to `auth.api.signOut(JWT: string)`\n     */\n    signOut() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n            this._removeSession();\n            this._notifyAllSubscribers('SIGNED_OUT');\n            if (accessToken) {\n                const { error } = yield this.api.signOut(accessToken);\n                if (error)\n                    return { error };\n            }\n            return { error: null };\n        });\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n     */\n    onAuthStateChange(callback) {\n        try {\n            const id = uuid();\n            const subscription = {\n                id,\n                callback,\n                unsubscribe: () => {\n                    this.stateChangeEmitters.delete(id);\n                },\n            };\n            this.stateChangeEmitters.set(id, subscription);\n            return { data: subscription, error: null };\n        }\n        catch (e) {\n            return { data: null, error: e };\n        }\n    }\n    _handleEmailSignIn(email, password, options = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data, error } = yield this.api.signInWithEmail(email, password, {\n                    redirectTo: options.redirectTo,\n                });\n                if (error || !data)\n                    return { data: null, user: null, session: null, error };\n                if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return { data, user: data.user, session: data, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, session: null, error: e };\n            }\n        });\n    }\n    _handlePhoneSignIn(phone, password) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data, error } = yield this.api.signInWithPhone(phone, password);\n                if (error || !data)\n                    return { data: null, user: null, session: null, error };\n                if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return { data, user: data.user, session: data, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, session: null, error: e };\n            }\n        });\n    }\n    _handleProviderSignIn(provider, options = {}) {\n        const url = this.api.getUrlForProvider(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n        });\n        try {\n            // try to open on the browser\n            if (isBrowser()) {\n                window.location.href = url;\n            }\n            return { provider, url, data: null, session: null, user: null, error: null };\n        }\n        catch (e) {\n            // fallback to returning the URL\n            if (url)\n                return { provider, url, data: null, session: null, user: null, error: null };\n            return { data: null, user: null, session: null, error: e };\n        }\n    }\n    _handleOpenIDConnectSignIn({ id_token, nonce, client_id, issuer, provider, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (id_token && nonce && ((client_id && issuer) || provider)) {\n                try {\n                    const { data, error } = yield this.api.signInWithOpenIDConnect({\n                        id_token,\n                        nonce,\n                        client_id,\n                        issuer,\n                        provider,\n                    });\n                    if (error || !data)\n                        return { user: null, session: null, error };\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                    return { user: data.user, session: data, error: null };\n                }\n                catch (e) {\n                    return { user: null, session: null, error: e };\n                }\n            }\n            throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`);\n        });\n    }\n    /**\n     * Attempts to get the session from LocalStorage\n     * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n     */\n    _recoverSession() {\n        try {\n            const data = getItemSynchronously(this.localStorage, STORAGE_KEY);\n            if (!data)\n                return null;\n            const { currentSession, expiresAt } = data;\n            const timeNow = Math.round(Date.now() / 1000);\n            if (expiresAt >= timeNow + EXPIRY_MARGIN && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n                this._saveSession(currentSession);\n                this._notifyAllSubscribers('SIGNED_IN');\n            }\n        }\n        catch (error) {\n            console.log('error', error);\n        }\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n    _recoverAndRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield getItemAsync(this.localStorage, STORAGE_KEY);\n                if (!data)\n                    return null;\n                const { currentSession, expiresAt } = data;\n                const timeNow = Math.round(Date.now() / 1000);\n                if (expiresAt < timeNow + EXPIRY_MARGIN) {\n                    if (this.autoRefreshToken && currentSession.refresh_token) {\n                        this.networkRetries++;\n                        const { error } = yield this._callRefreshToken(currentSession.refresh_token);\n                        if (error) {\n                            console.log(error.message);\n                            if (error.message === NETWORK_FAILURE.ERROR_MESSAGE &&\n                                this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) {\n                                if (this.refreshTokenTimer)\n                                    clearTimeout(this.refreshTokenTimer);\n                                this.refreshTokenTimer = setTimeout(() => this._recoverAndRefresh(), Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                                );\n                                return;\n                            }\n                            yield this._removeSession();\n                        }\n                        this.networkRetries = 0;\n                    }\n                    else {\n                        this._removeSession();\n                    }\n                }\n                else if (!currentSession) {\n                    console.log('Current session is missing data.');\n                    this._removeSession();\n                }\n                else {\n                    // should be handled on _recoverSession method already\n                    // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n                    this._saveSession(currentSession);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n            }\n            catch (err) {\n                console.error(err);\n                return null;\n            }\n        });\n    }\n    _callRefreshToken(refresh_token) {\n        var _a;\n        if (refresh_token === void 0) { refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token; }\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!refresh_token) {\n                    throw new Error('No current session.');\n                }\n                const { data, error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error)\n                    throw error;\n                if (!data)\n                    throw Error('Invalid session data.');\n                this._saveSession(data);\n                this._notifyAllSubscribers('TOKEN_REFRESHED');\n                this._notifyAllSubscribers('SIGNED_IN');\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    _notifyAllSubscribers(event) {\n        this.stateChangeEmitters.forEach((x) => x.callback(event, this.currentSession));\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n    _saveSession(session) {\n        this.currentSession = session;\n        this.currentUser = session.user;\n        const expiresAt = session.expires_at;\n        if (expiresAt) {\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = expiresAt - timeNow;\n            const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n            this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n        }\n        // Do we need any extra check before persist session\n        // access_token or user ?\n        if (this.persistSession && session.expires_at) {\n            this._persistSession(this.currentSession);\n        }\n    }\n    _persistSession(currentSession) {\n        const data = { currentSession, expiresAt: currentSession.expires_at };\n        setItemAsync(this.localStorage, STORAGE_KEY, data);\n    }\n    _removeSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.currentSession = null;\n            this.currentUser = null;\n            if (this.refreshTokenTimer)\n                clearTimeout(this.refreshTokenTimer);\n            removeItemAsync(this.localStorage, STORAGE_KEY);\n        });\n    }\n    /**\n     * Clear and re-create refresh token timer\n     * @param value time intervals in milliseconds\n     */\n    _startAutoRefreshToken(value) {\n        if (this.refreshTokenTimer)\n            clearTimeout(this.refreshTokenTimer);\n        if (value <= 0 || !this.autoRefreshToken)\n            return;\n        this.refreshTokenTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            this.networkRetries++;\n            const { error } = yield this._callRefreshToken();\n            if (!error)\n                this.networkRetries = 0;\n            if ((error === null || error === void 0 ? void 0 : error.message) === NETWORK_FAILURE.ERROR_MESSAGE &&\n                this.networkRetries < NETWORK_FAILURE.MAX_RETRIES)\n                this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n        }), value);\n        if (typeof this.refreshTokenTimer.unref === 'function')\n            this.refreshTokenTimer.unref();\n    }\n    /**\n     * Listens for changes to LocalStorage and updates the current session.\n     */\n    _listenForMultiTabEvents() {\n        if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            return false;\n        }\n        try {\n            window === null || window === void 0 ? void 0 : window.addEventListener('storage', (e) => {\n                var _a;\n                if (e.key === STORAGE_KEY) {\n                    const newSession = JSON.parse(String(e.newValue));\n                    if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n                        this._saveSession(newSession.currentSession);\n                        this._notifyAllSubscribers('SIGNED_IN');\n                    }\n                    else {\n                        this._removeSession();\n                        this._notifyAllSubscribers('SIGNED_OUT');\n                    }\n                }\n            });\n        }\n        catch (error) {\n            console.error('_listenForMultiTabEvents', error);\n        }\n    }\n    _handleVisibilityChange() {\n        if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            return false;\n        }\n        try {\n            window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'visible') {\n                    this._recoverAndRefresh();\n                }\n            });\n        }\n        catch (error) {\n            console.error('_handleVisibilityChange', error);\n        }\n    }\n}\n//# sourceMappingURL=GoTrueClient.js.map"]},"metadata":{},"sourceType":"module"}