{"ast":null,"code":"import _classCallCheck from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\n\nvar RealtimeChannel = /*#__PURE__*/function () {\n  function RealtimeChannel(topic) {\n    var _this = this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var socket = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, RealtimeChannel);\n\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = [];\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(function () {\n      return _this.rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', function () {\n      _this.state = CHANNEL_STATES.joined;\n\n      _this.rejoinTimer.reset();\n\n      _this.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n\n      _this.pushBuffer = [];\n    });\n    this.onClose(function () {\n      _this.rejoinTimer.reset();\n\n      _this.socket.log('channel', \"close \".concat(_this.topic, \" \").concat(_this.joinRef()));\n\n      _this.state = CHANNEL_STATES.closed;\n\n      _this.socket.remove(_this);\n    });\n    this.onError(function (reason) {\n      if (_this.isLeaving() || _this.isClosed()) {\n        return;\n      }\n\n      _this.socket.log('channel', \"error \".concat(_this.topic), reason);\n\n      _this.state = CHANNEL_STATES.errored;\n\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', function () {\n      if (!_this.isJoining()) {\n        return;\n      }\n\n      _this.socket.log('channel', \"timeout \".concat(_this.topic), _this.joinPush.timeout);\n\n      _this.state = CHANNEL_STATES.errored;\n\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, {}, function (payload, ref) {\n      _this.trigger(_this.replyEventName(ref), payload);\n    });\n    this.presence = new RealtimePresence(this);\n  }\n\n  _createClass(RealtimeChannel, [{\n    key: \"list\",\n    value: function list() {\n      return this.presence.list();\n    }\n  }, {\n    key: \"rejoinUntilConnected\",\n    value: function rejoinUntilConnected() {\n      this.rejoinTimer.scheduleTimeout();\n\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.joinedOnce) {\n        throw \"tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance\";\n      } else {\n        var configs = this.bindings.reduce(function (acc, binding) {\n          var type = binding.type;\n\n          if (!['phx_close', 'phx_error', 'phx_reply', 'presence_diff', 'presence_state'].includes(type)) {\n            acc[type] = binding;\n          }\n\n          return acc;\n        }, {});\n\n        if (Object.keys(configs).length) {\n          this.updateJoinPayload({\n            configs: configs\n          });\n        }\n\n        this.joinedOnce = true;\n        this.rejoin(timeout);\n        return this.joinPush;\n      }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     */\n\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     */\n\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.on(CHANNEL_EVENTS.error, {}, function (reason) {\n        return callback(reason);\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(type, filter, callback) {\n      this.bindings.push({\n        type: type,\n        filter: filter !== null && filter !== void 0 ? filter : {},\n        callback: callback !== null && callback !== void 0 ? callback : function () {}\n      });\n    }\n  }, {\n    key: \"off\",\n    value: function off(type, filter) {\n      this.bindings = this.bindings.filter(function (bind) {\n        return !(bind.type === type && RealtimeChannel.isEqual(bind.filter, filter));\n      });\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     */\n\n  }, {\n    key: \"canPush\",\n    value: function canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n  }, {\n    key: \"push\",\n    value: function push(event, payload) {\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n\n      if (!this.joinedOnce) {\n        throw \"tried to push '\".concat(event, \"' to '\").concat(this.topic, \"' before joining. Use channel.subscribe() before pushing events\");\n      }\n\n      var pushEvent = new Push(this, event, payload, timeout);\n\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n  }, {\n    key: \"updateJoinPayload\",\n    value: function updateJoinPayload(payload) {\n      this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _this2 = this;\n\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      this.state = CHANNEL_STATES.leaving;\n\n      var onClose = function onClose() {\n        _this2.socket.log('channel', \"leave \".concat(_this2.topic));\n\n        _this2.trigger(CHANNEL_EVENTS.close, 'leave', _this2.joinRef());\n      }; // Destroy joinPush to avoid connection timeouts during unscription phase\n\n\n      this.joinPush.destroy();\n      var leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', function () {\n        return onClose();\n      }).receive('timeout', function () {\n        return onClose();\n      });\n      leavePush.send();\n\n      if (!this.canPush()) {\n        leavePush.trigger('ok', {});\n      }\n\n      return leavePush;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     */\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event, payload, ref) {\n      return payload;\n    }\n  }, {\n    key: \"isMember\",\n    value: function isMember(topic) {\n      return this.topic === topic;\n    }\n  }, {\n    key: \"joinRef\",\n    value: function joinRef() {\n      return this.joinPush.ref;\n    }\n  }, {\n    key: \"rejoin\",\n    value: function rejoin() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.isLeaving()) {\n        return;\n      }\n\n      this.socket.leaveOpenTopic(this.topic);\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(type, payload, ref) {\n      var close = CHANNEL_EVENTS.close,\n          error = CHANNEL_EVENTS.error,\n          leave = CHANNEL_EVENTS.leave,\n          join = CHANNEL_EVENTS.join;\n      var events = [close, error, leave, join];\n\n      if (ref && events.indexOf(type) >= 0 && ref !== this.joinRef()) {\n        return;\n      }\n\n      var handledPayload = this.onMessage(type, payload, ref);\n\n      if (payload && !handledPayload) {\n        throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n      }\n\n      this.bindings.filter(function (bind) {\n        var _a, _b;\n\n        return (bind === null || bind === void 0 ? void 0 : bind.type) === type && (((_a = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_b = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _b === void 0 ? void 0 : _b.event) === (payload === null || payload === void 0 ? void 0 : payload.event));\n      }).map(function (bind) {\n        return bind.callback(handledPayload, ref);\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(payload) {\n      var push = this.push(payload.type, payload);\n      return new Promise(function (resolve, reject) {\n        push.receive('ok', function () {\n          return resolve('ok');\n        });\n        push.receive('timeout', function () {\n          return reject('timeout');\n        });\n      });\n    }\n  }, {\n    key: \"replyEventName\",\n    value: function replyEventName(ref) {\n      return \"chan_reply_\".concat(ref);\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n  }, {\n    key: \"isErrored\",\n    value: function isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n  }, {\n    key: \"isJoined\",\n    value: function isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n  }, {\n    key: \"isJoining\",\n    value: function isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n  }, {\n    key: \"isLeaving\",\n    value: function isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n  }], [{\n    key: \"isEqual\",\n    value: function isEqual(obj1, obj2) {\n      if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n        return false;\n      }\n\n      for (var k in obj1) {\n        if (obj1[k] !== obj2[k]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return RealtimeChannel;\n}();\n\nexport { RealtimeChannel as default };","map":{"version":3,"sources":["../../src/RealtimeChannel.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nexport default class RealtimeChannel {\n    constructor(topic, params = {}, socket) {\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = [];\n        this.state = CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.timeout = this.socket.timeout;\n        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new Timer(() => this.rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', () => {\n            this.state = CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this.onClose(() => {\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`);\n            this.state = CHANNEL_STATES.closed;\n            this.socket.remove(this);\n        });\n        this.onError((reason) => {\n            if (this.isLeaving() || this.isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', () => {\n            if (!this.isJoining()) {\n                return;\n            }\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n            this.trigger(this.replyEventName(ref), payload);\n        });\n        this.presence = new RealtimePresence(this);\n    }\n    list() {\n        return this.presence.list();\n    }\n    rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this.rejoin();\n        }\n    }\n    subscribe(timeout = this.timeout) {\n        if (this.joinedOnce) {\n            throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n        }\n        else {\n            const configs = this.bindings.reduce((acc, binding) => {\n                const { type } = binding;\n                if (![\n                    'phx_close',\n                    'phx_error',\n                    'phx_reply',\n                    'presence_diff',\n                    'presence_state',\n                ].includes(type)) {\n                    acc[type] = binding;\n                }\n                return acc;\n            }, {});\n            if (Object.keys(configs).length) {\n                this.updateJoinPayload({ configs });\n            }\n            this.joinedOnce = true;\n            this.rejoin(timeout);\n            return this.joinPush;\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     */\n    onClose(callback) {\n        this.on(CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     */\n    onError(callback) {\n        this.on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\n    }\n    on(type, filter, callback) {\n        this.bindings.push({\n            type,\n            filter: filter !== null && filter !== void 0 ? filter : {},\n            callback: callback !== null && callback !== void 0 ? callback : (() => { }),\n        });\n    }\n    off(type, filter) {\n        this.bindings = this.bindings.filter((bind) => {\n            return !(bind.type === type && RealtimeChannel.isEqual(bind.filter, filter));\n        });\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     */\n    canPush() {\n        return this.socket.isConnected() && this.isJoined();\n    }\n    push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new Push(this, event, payload, timeout);\n        if (this.canPush()) {\n            pushEvent.send();\n        }\n        else {\n            pushEvent.startTimeout();\n            this.pushBuffer.push(pushEvent);\n        }\n        return pushEvent;\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n    unsubscribe(timeout = this.timeout) {\n        this.state = CHANNEL_STATES.leaving;\n        const onClose = () => {\n            this.socket.log('channel', `leave ${this.topic}`);\n            this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef());\n        };\n        // Destroy joinPush to avoid connection timeouts during unscription phase\n        this.joinPush.destroy();\n        const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n        leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose());\n        leavePush.send();\n        if (!this.canPush()) {\n            leavePush.trigger('ok', {});\n        }\n        return leavePush;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     */\n    onMessage(event, payload, ref) {\n        return payload;\n    }\n    isMember(topic) {\n        return this.topic === topic;\n    }\n    joinRef() {\n        return this.joinPush.ref;\n    }\n    rejoin(timeout = this.timeout) {\n        if (this.isLeaving()) {\n            return;\n        }\n        this.socket.leaveOpenTopic(this.topic);\n        this.state = CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    trigger(type, payload, ref) {\n        const { close, error, leave, join } = CHANNEL_EVENTS;\n        const events = [close, error, leave, join];\n        if (ref && events.indexOf(type) >= 0 && ref !== this.joinRef()) {\n            return;\n        }\n        const handledPayload = this.onMessage(type, payload, ref);\n        if (payload && !handledPayload) {\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        }\n        this.bindings\n            .filter((bind) => {\n            var _a, _b;\n            return ((bind === null || bind === void 0 ? void 0 : bind.type) === type &&\n                (((_a = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' ||\n                    ((_b = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _b === void 0 ? void 0 : _b.event) === (payload === null || payload === void 0 ? void 0 : payload.event)));\n        })\n            .map((bind) => bind.callback(handledPayload, ref));\n    }\n    send(payload) {\n        const push = this.push(payload.type, payload);\n        return new Promise((resolve, reject) => {\n            push.receive('ok', () => resolve('ok'));\n            push.receive('timeout', () => reject('timeout'));\n        });\n    }\n    replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    isClosed() {\n        return this.state === CHANNEL_STATES.closed;\n    }\n    isErrored() {\n        return this.state === CHANNEL_STATES.errored;\n    }\n    isJoined() {\n        return this.state === CHANNEL_STATES.joined;\n    }\n    isJoining() {\n        return this.state === CHANNEL_STATES.joining;\n    }\n    isLeaving() {\n        return this.state === CHANNEL_STATES.leaving;\n    }\n    static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (const k in obj1) {\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=RealtimeChannel.js.map"]},"metadata":{},"sourceType":"module"}