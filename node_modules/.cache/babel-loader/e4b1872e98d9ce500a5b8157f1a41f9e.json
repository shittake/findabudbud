{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/ericl/findabudbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeSubscription from './RealtimeSubscription';\nimport RealtimeChannel from './RealtimeChannel';\n\nvar noop = function noop() {};\n\nvar RealtimeClient = /*#__PURE__*/function () {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  function RealtimeClient(endPoint, options) {\n    var _this = this;\n\n    _classCallCheck(this, RealtimeClient);\n\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = w3cwebsocket;\n    this.heartbeatIntervalMs = 30000;\n    this.longpollerTimeout = 20000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.endPoint = \"\".concat(endPoint, \"/\").concat(TRANSPORTS.websocket);\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    if (options === null || options === void 0 ? void 0 : options.longpollerTimeout) this.longpollerTimeout = options.longpollerTimeout;\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : function (payload, callback) {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(function () {\n      return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.disconnect();\n\n              case 2:\n                this.connect();\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }, this.reconnectAfterMs);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n\n\n  _createClass(RealtimeClient, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n\n      if (this.conn) {\n        return;\n      }\n\n      this.conn = new this.transport(this.endPointURL(), [], null, this.headers);\n\n      if (this.conn) {\n        // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\n        this.conn.binaryType = 'arraybuffer';\n\n        this.conn.onopen = function () {\n          return _this2._onConnOpen();\n        };\n\n        this.conn.onerror = function (error) {\n          return _this2._onConnError(error);\n        };\n\n        this.conn.onmessage = function (event) {\n          return _this2.onConnMessage(event);\n        };\n\n        this.conn.onclose = function (event) {\n          return _this2._onConnClose(event);\n        };\n      }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(code, reason) {\n      var _this3 = this;\n\n      return new Promise(function (resolve, _reject) {\n        try {\n          if (_this3.conn) {\n            _this3.conn.onclose = function () {}; // noop\n\n\n            if (code) {\n              _this3.conn.close(code, reason || '');\n            } else {\n              _this3.conn.close();\n            }\n\n            _this3.conn = null; // remove open handles\n\n            _this3.heartbeatTimer && clearInterval(_this3.heartbeatTimer);\n\n            _this3.reconnectTimer.reset();\n          }\n\n          resolve({\n            error: null,\n            data: true\n          });\n        } catch (error) {\n          resolve({\n            error: error,\n            data: false\n          });\n        }\n      });\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overriden.\n     */\n\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n    /**\n     * Registers a callback for connection state change event.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen(() => console.log(\"Socket opened.\"))\n     */\n\n  }, {\n    key: \"onOpen\",\n    value: function onOpen(callback) {\n      this.stateChangeCallbacks.open.push(callback);\n    }\n    /**\n     * Registers a callback for connection state change events.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen(() => console.log(\"Socket closed.\"))\n     */\n\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.stateChangeCallbacks.close.push(callback);\n    }\n    /**\n     * Registers a callback for connection state change events.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen((error) => console.log(\"An error occurred\"))\n     */\n\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.stateChangeCallbacks.error.push(callback);\n    }\n    /**\n     * Calls a function any time a message is received.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onMessage((message) => console.log(message))\n     */\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(callback) {\n      this.stateChangeCallbacks.message.push(callback);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return CONNECTION_STATE.Connecting;\n\n        case SOCKET_STATES.open:\n          return CONNECTION_STATE.Open;\n\n        case SOCKET_STATES.closing:\n          return CONNECTION_STATE.Closing;\n\n        default:\n          return CONNECTION_STATE.Closed;\n      }\n    }\n    /**\n     * Retuns `true` is the connection is open.\n     */\n\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === CONNECTION_STATE.Open;\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return c.joinRef() !== channel.joinRef();\n      });\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var chanParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _a;\n\n      var selfBroadcast = chanParams.selfBroadcast,\n          params = __rest(chanParams, [\"selfBroadcast\"]);\n\n      if (selfBroadcast) {\n        params.self_broadcast = selfBroadcast;\n      }\n\n      var chan = ((_a = this.params) === null || _a === void 0 ? void 0 : _a.vsndate) ? new RealtimeChannel(topic, params, this) : new RealtimeSubscription(topic, params, this);\n\n      if (chan instanceof RealtimeChannel) {\n        chan.presence.onJoin(function (key, currentPresences, newPresences) {\n          chan.trigger('presence', {\n            event: 'JOIN',\n            key: key,\n            currentPresences: currentPresences,\n            newPresences: newPresences\n          });\n        });\n        chan.presence.onLeave(function (key, currentPresences, leftPresences) {\n          chan.trigger('presence', {\n            event: 'LEAVE',\n            key: key,\n            currentPresences: currentPresences,\n            leftPresences: leftPresences\n          });\n        });\n        chan.presence.onSync(function () {\n          chan.trigger('presence', {\n            event: 'SYNC'\n          });\n        });\n      }\n\n      this.channels.push(chan);\n      return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this4 = this;\n\n      var topic = data.topic,\n          event = data.event,\n          payload = data.payload,\n          ref = data.ref;\n\n      var callback = function callback() {\n        _this4.encode(data, function (result) {\n          var _a;\n\n          (_a = _this4.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n        });\n      };\n\n      this.log('push', \"\".concat(topic, \" \").concat(event, \" (\").concat(ref, \")\"), payload);\n\n      if (this.isConnected()) {\n        callback();\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    }\n  }, {\n    key: \"onConnMessage\",\n    value: function onConnMessage(rawMessage) {\n      var _this5 = this;\n\n      this.decode(rawMessage.data, function (msg) {\n        var topic = msg.topic,\n            event = msg.event,\n            payload = msg.payload,\n            ref = msg.ref;\n\n        if (ref && ref === _this5.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n          _this5.pendingHeartbeatRef = null;\n        }\n\n        _this5.log('receive', \"\".concat(payload.status || '', \" \").concat(topic, \" \").concat(event, \" \").concat(ref && '(' + ref + ')' || ''), payload);\n\n        _this5.channels.filter(function (channel) {\n          return channel.isMember(topic);\n        }).forEach(function (channel) {\n          return channel.trigger(event, payload, ref);\n        });\n\n        _this5.stateChangeCallbacks.message.forEach(function (callback) {\n          return callback(msg);\n        });\n      });\n    }\n    /**\n     * Returns the URL of the websocket.\n     */\n\n  }, {\n    key: \"endPointURL\",\n    value: function endPointURL() {\n      return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n        vsn: VSN\n      }));\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     */\n\n  }, {\n    key: \"makeRef\",\n    value: function makeRef() {\n      var newRef = this.ref + 1;\n\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n\n  }, {\n    key: \"setAuth\",\n    value: function setAuth(token) {\n      this.accessToken = token;\n      this.channels.forEach(function (channel) {\n        token && channel.updateJoinPayload({\n          user_token: token\n        });\n\n        if (channel.joinedOnce && channel.isJoined()) {\n          channel.push(CHANNEL_EVENTS.access_token, {\n            access_token: token\n          });\n        }\n      });\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     */\n\n  }, {\n    key: \"leaveOpenTopic\",\n    value: function leaveOpenTopic(topic) {\n      var dupChannel = this.channels.find(function (c) {\n        return c.topic === topic && (c.isJoined() || c.isJoining());\n      });\n\n      if (dupChannel) {\n        this.log('transport', \"leaving duplicate topic \\\"\".concat(topic, \"\\\"\"));\n        dupChannel.unsubscribe();\n      }\n    }\n  }, {\n    key: \"_onConnOpen\",\n    value: function _onConnOpen() {\n      var _this6 = this;\n\n      this.log('transport', \"connected to \".concat(this.endPointURL()));\n\n      this._flushSendBuffer();\n\n      this.reconnectTimer.reset();\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = setInterval(function () {\n        return _this6._sendHeartbeat();\n      }, this.heartbeatIntervalMs);\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n  }, {\n    key: \"_onConnClose\",\n    value: function _onConnClose(event) {\n      this.log('transport', 'close', event);\n\n      this._triggerChanError();\n\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n  }, {\n    key: \"_onConnError\",\n    value: function _onConnError(error) {\n      this.log('transport', error.message);\n\n      this._triggerChanError();\n\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n  }, {\n    key: \"_triggerChanError\",\n    value: function _triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel.trigger(CHANNEL_EVENTS.error);\n      });\n    }\n  }, {\n    key: \"_appendParams\",\n    value: function _appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      var prefix = url.match(/\\?/) ? '&' : '?';\n      var query = new URLSearchParams(params);\n      return \"\".concat(url).concat(prefix).concat(query);\n    }\n  }, {\n    key: \"_flushSendBuffer\",\n    value: function _flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n  }, {\n    key: \"_sendHeartbeat\",\n    value: function _sendHeartbeat() {\n      var _a;\n\n      if (!this.isConnected()) {\n        return;\n      }\n\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n        this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n        return;\n      }\n\n      this.pendingHeartbeatRef = this.makeRef();\n      this.push({\n        topic: 'phoenix',\n        event: 'heartbeat',\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n      this.setAuth(this.accessToken);\n    }\n  }]);\n\n  return RealtimeClient;\n}();\n\nexport { RealtimeClient as default };","map":{"version":3,"sources":["../../src/RealtimeClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE, } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeSubscription from './RealtimeSubscription';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => { };\nexport default class RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket.\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers The optional headers to pass when connecting.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     */\n    constructor(endPoint, options) {\n        this.accessToken = null;\n        this.channels = [];\n        this.endPoint = '';\n        this.headers = DEFAULT_HEADERS;\n        this.params = {};\n        this.timeout = DEFAULT_TIMEOUT;\n        this.transport = w3cwebsocket;\n        this.heartbeatIntervalMs = 30000;\n        this.longpollerTimeout = 20000;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.ref = 0;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new Serializer();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: [],\n        };\n        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n        if (options === null || options === void 0 ? void 0 : options.params)\n            this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.headers)\n            this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n        if (options === null || options === void 0 ? void 0 : options.timeout)\n            this.timeout = options.timeout;\n        if (options === null || options === void 0 ? void 0 : options.logger)\n            this.logger = options.logger;\n        if (options === null || options === void 0 ? void 0 : options.transport)\n            this.transport = options.transport;\n        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)\n            this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n        if (options === null || options === void 0 ? void 0 : options.longpollerTimeout)\n            this.longpollerTimeout = options.longpollerTimeout;\n        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs\n            : (tries) => {\n                return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n            };\n        this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode\n            : (payload, callback) => {\n                return callback(JSON.stringify(payload));\n            };\n        this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode\n            : this.serializer.decode.bind(this.serializer);\n        this.reconnectTimer = new Timer(() => __awaiter(this, void 0, void 0, function* () {\n            yield this.disconnect();\n            this.connect();\n        }), this.reconnectAfterMs);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */\n    connect() {\n        if (this.conn) {\n            return;\n        }\n        this.conn = new this.transport(this.endPointURL(), [], null, this.headers);\n        if (this.conn) {\n            // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\n            this.conn.binaryType = 'arraybuffer';\n            this.conn.onopen = () => this._onConnOpen();\n            this.conn.onerror = (error) => this._onConnError(error);\n            this.conn.onmessage = (event) => this.onConnMessage(event);\n            this.conn.onclose = (event) => this._onConnClose(event);\n        }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n    disconnect(code, reason) {\n        return new Promise((resolve, _reject) => {\n            try {\n                if (this.conn) {\n                    this.conn.onclose = function () { }; // noop\n                    if (code) {\n                        this.conn.close(code, reason || '');\n                    }\n                    else {\n                        this.conn.close();\n                    }\n                    this.conn = null;\n                    // remove open handles\n                    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n                    this.reconnectTimer.reset();\n                }\n                resolve({ error: null, data: true });\n            }\n            catch (error) {\n                resolve({ error: error, data: false });\n            }\n        });\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overriden.\n     */\n    log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Registers a callback for connection state change event.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen(() => console.log(\"Socket opened.\"))\n     */\n    onOpen(callback) {\n        this.stateChangeCallbacks.open.push(callback);\n    }\n    /**\n     * Registers a callback for connection state change events.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen(() => console.log(\"Socket closed.\"))\n     */\n    onClose(callback) {\n        this.stateChangeCallbacks.close.push(callback);\n    }\n    /**\n     * Registers a callback for connection state change events.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen((error) => console.log(\"An error occurred\"))\n     */\n    onError(callback) {\n        this.stateChangeCallbacks.error.push(callback);\n    }\n    /**\n     * Calls a function any time a message is received.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onMessage((message) => console.log(message))\n     */\n    onMessage(callback) {\n        this.stateChangeCallbacks.message.push(callback);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n    connectionState() {\n        switch (this.conn && this.conn.readyState) {\n            case SOCKET_STATES.connecting:\n                return CONNECTION_STATE.Connecting;\n            case SOCKET_STATES.open:\n                return CONNECTION_STATE.Open;\n            case SOCKET_STATES.closing:\n                return CONNECTION_STATE.Closing;\n            default:\n                return CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Retuns `true` is the connection is open.\n     */\n    isConnected() {\n        return this.connectionState() === CONNECTION_STATE.Open;\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     */\n    remove(channel) {\n        this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());\n    }\n    channel(topic, chanParams = {}) {\n        var _a;\n        const { selfBroadcast } = chanParams, params = __rest(chanParams, [\"selfBroadcast\"]);\n        if (selfBroadcast) {\n            params.self_broadcast = selfBroadcast;\n        }\n        const chan = ((_a = this.params) === null || _a === void 0 ? void 0 : _a.vsndate) ? new RealtimeChannel(topic, params, this)\n            : new RealtimeSubscription(topic, params, this);\n        if (chan instanceof RealtimeChannel) {\n            chan.presence.onJoin((key, currentPresences, newPresences) => {\n                chan.trigger('presence', {\n                    event: 'JOIN',\n                    key,\n                    currentPresences,\n                    newPresences,\n                });\n            });\n            chan.presence.onLeave((key, currentPresences, leftPresences) => {\n                chan.trigger('presence', {\n                    event: 'LEAVE',\n                    key,\n                    currentPresences,\n                    leftPresences,\n                });\n            });\n            chan.presence.onSync(() => {\n                chan.trigger('presence', { event: 'SYNC' });\n            });\n        }\n        this.channels.push(chan);\n        return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n    push(data) {\n        const { topic, event, payload, ref } = data;\n        let callback = () => {\n            this.encode(data, (result) => {\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        }\n        else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg) => {\n            let { topic, event, payload, ref } = msg;\n            if ((ref && ref === this.pendingHeartbeatRef) ||\n                event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n                this.pendingHeartbeatRef = null;\n            }\n            this.log('receive', `${payload.status || ''} ${topic} ${event} ${(ref && '(' + ref + ')') || ''}`, payload);\n            this.channels\n                .filter((channel) => channel.isMember(topic))\n                .forEach((channel) => channel.trigger(event, payload, ref));\n            this.stateChangeCallbacks.message.forEach((callback) => callback(msg));\n        });\n    }\n    /**\n     * Returns the URL of the websocket.\n     */\n    endPointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     */\n    makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        }\n        else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n    setAuth(token) {\n        this.accessToken = token;\n        this.channels.forEach((channel) => {\n            token && channel.updateJoinPayload({ user_token: token });\n            if (channel.joinedOnce && channel.isJoined()) {\n                channel.push(CHANNEL_EVENTS.access_token, { access_token: token });\n            }\n        });\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     */\n    leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    _onConnOpen() {\n        this.log('transport', `connected to ${this.endPointURL()}`);\n        this._flushSendBuffer();\n        this.reconnectTimer.reset();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n        this.stateChangeCallbacks.open.forEach((callback) => callback());\n    }\n    _onConnClose(event) {\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.scheduleTimeout();\n        this.stateChangeCallbacks.close.forEach((callback) => callback(event));\n    }\n    _onConnError(error) {\n        this.log('transport', error.message);\n        this._triggerChanError();\n        this.stateChangeCallbacks.error.forEach((callback) => callback(error));\n    }\n    _triggerChanError() {\n        this.channels.forEach((channel) => channel.trigger(CHANNEL_EVENTS.error));\n    }\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback) => callback());\n            this.sendBuffer = [];\n        }\n    }\n    _sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            return;\n        }\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n            return;\n        }\n        this.pendingHeartbeatRef = this.makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef,\n        });\n        this.setAuth(this.accessToken);\n    }\n}\n//# sourceMappingURL=RealtimeClient.js.map"]},"metadata":{},"sourceType":"module"}